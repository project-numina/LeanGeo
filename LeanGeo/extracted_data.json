[
    {
        "name": "construct_perpBisector (a b",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem construct_perpBisector (a b : Point) : ¬ (a ≠ b) →  ∃ L, perpBisector a b L := by\n",
        "formal_proof": "theorem construct_perpBisector (a b : Point) : ¬ (a ≠ b) →  ∃ L, perpBisector a b L := by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "exists_centre",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exists_centre : ∀ (O: Circle), ∃ (C : Point), C.isCentre O := by\n",
        "formal_proof": "theorem exists_centre : ∀ (O: Circle), ∃ (C : Point), C.isCentre O := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "exists_midpoint",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exists_midpoint : ∀ (A B : Point), ∃(P : Point), midpoint A P B := by\n",
        "formal_proof": "theorem exists_midpoint : ∀ (A B : Point), ∃(P : Point), midpoint A P B := by\n  sorry\n\n--theorem exists_foot : ∀ (A : Point) (l : Line), ∃(P : Point), P.onLine l ∧\n--(∀ Q:Point, Q.onLine l → ∠A:P:Q = ∟) := by\n--  sorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "midpoint_twice",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem midpoint_twice: ∀ (A B P : Point), midpoint A P B → |(A─B)| * 1/2 = |(P─B)|  := by\n",
        "formal_proof": "theorem midpoint_twice: ∀ (A B P : Point), midpoint A P B → |(A─B)| * 1/2 = |(P─B)|  := by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "exists_foot",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exists_foot : ∀ (c a b : Point) (AB : Line),\n  distinctPointsOnLine a b AB ∧ ¬(c.onLine AB) →\n  exists h : Point, h.onLine AB ∧ (∠ a:h:c = ∟ ∨ ∠ b:h:c = ∟) :=\nby\n  sorry\n\n",
        "formal_proof": "theorem exists_foot : ∀ (c a b : Point) (AB : Line),\n  distinctPointsOnLine a b AB ∧ ¬(c.onLine AB) →\n  exists h : Point, h.onLine AB ∧ (∠ a:h:c = ∟ ∨ ∠ b:h:c = ∟) :=\nby\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "exists_angleBisection",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exists_angleBisection : ∀ (A B C : Point),\n(A ≠ B) ∧ (A ≠ C) ∧ ¬(coll A B C)\n→ ∃ (L : Line), ∀ (P: Point), P.onLine L ↔ ∠ A:B:P = ∠ P:B:C\n:= by\n",
        "formal_proof": "theorem exists_angleBisection : ∀ (A B C : Point),\n(A ≠ B) ∧ (A ≠ C) ∧ ¬(coll A B C)\n→ ∃ (L : Line), ∀ (P: Point), P.onLine L ↔ ∠ A:B:P = ∠ P:B:C\n:= by\n    sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "supplementaryAngle_line",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem supplementaryAngle_line : ∀ (d a b c: Point), (between a b c) ∧ (¬ coll a b d) → ∠d:b:a + ∠d:b:c = ∟ + ∟ := by\n",
        "formal_proof": "theorem supplementaryAngle_line : ∀ (d a b c: Point), (between a b c) ∧ (¬ coll a b d) → ∠d:b:a + ∠d:b:c = ∟ + ∟ := by\n  sorry\n\n\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "coll_exist_line",
        "using_lemmas": [
            "euclid_apply",
            "line_from_points",
            "euclid_apply",
            "euclid_apply"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem coll_exist_line : ∀ (A B C : Point), coll A B C →  ∃(l:Line),\nA.onLine l ∧ B.onLine l ∧ C.onLine l := by\n",
        "formal_proof": "theorem coll_exist_line : ∀ (A B C : Point), coll A B C →  ∃(l:Line),\nA.onLine l ∧ B.onLine l ∧ C.onLine l := by\n  euclid_intros\n  by_cases h : A = B\n  · by_cases h2 : B = C\n    · euclid_apply distinct_points\n      euclid_apply line_from_points\n      euclid_finish\n    · euclid_apply line_from_points B C as BC\n      use BC\n      euclid_finish\n  · euclid_apply line_from_points A B as AB\n    use AB\n    euclid_finish\n\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "point_not_onLine",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem point_not_onLine : ∀(A B C : Point) (l :Line), ¬ coll A B C ∧ distinctPointsOnLine B C l → ¬ A.onLine l := by\n",
        "formal_proof": "theorem point_not_onLine : ∀(A B C : Point) (l :Line), ¬ coll A B C ∧ distinctPointsOnLine B C l → ¬ A.onLine l := by\n  euclid_intros\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "unique_perpLine",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem unique_perpLine : ∀ (A : Point) (L : Line),\n  ¬(A.onLine L)\n  → ∃! (M : Line),\n    A.onLine M\n    ∧ perpLine L M\n    :=\nby\n  sorry\n\n--Angle\n",
        "formal_proof": "theorem unique_perpLine : ∀ (A : Point) (L : Line),\n  ¬(A.onLine L)\n  → ∃! (M : Line),\n    A.onLine M\n    ∧ perpLine L M\n    :=\nby\n  sorry\n\n--Angle\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "angle_coincide_zero",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem angle_coincide_zero : ∀ (a o : Point), (a ≠ o) → ∠a:o:a = 0:= by\n",
        "formal_proof": "theorem angle_coincide_zero : ∀ (a o : Point), (a ≠ o) → ∠a:o:a = 0:= by\n  sorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "angle_positive_neq",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem angle_positive_neq : ∀ (a o b : Point), (∠a:o:b>0) → (a ≠ b) ∧ (a ≠ o) ∧ (b ≠ o) := by\n",
        "formal_proof": "theorem angle_positive_neq : ∀ (a o b : Point), (∠a:o:b>0) → (a ≠ b) ∧ (a ≠ o) ∧ (b ≠ o) := by\n  sorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "angle_between_transfer",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem angle_between_transfer : ∀ (a b c d : Point),between a b c ∧ ¬ coll a b d → ∠d:c:b = ∠d:c:a ∧ ∠d:b:c + ∠d:b:a = ∟ + ∟ := by\n",
        "formal_proof": "theorem angle_between_transfer : ∀ (a b c d : Point),between a b c ∧ ¬ coll a b d → ∠d:c:b = ∠d:c:a ∧ ∠d:b:c + ∠d:b:a = ∟ + ∟ := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "rightAngle_eq_pi_div_two",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem rightAngle_eq_pi_div_two : ∟ = Real.pi / 2 := by\n",
        "formal_proof": "theorem rightAngle_eq_pi_div_two : ∟ = Real.pi / 2 := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "sin_rightAngle",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem sin_rightAngle : Real.sin ∟ = 1 := by\n",
        "formal_proof": "theorem sin_rightAngle : Real.sin ∟ = 1 := by\n  rw [rightAngle_eq_pi_div_two]\n  rw [Real.sin_pi_div_two]\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "cos_rightAngle",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem cos_rightAngle : Real.cos ∟ = 0 := by\n",
        "formal_proof": "theorem cos_rightAngle : Real.cos ∟ = 0 := by\n  rw [rightAngle_eq_pi_div_two]\n  rw [Real.cos_pi_div_two]\n\n\n--perpBisector\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpBisector_property",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpBisector_property : ∀ (A B : Point) (L : Line),\n  perpBisector A B L →\n  (∀ (X : Point), X.onLine L → |(X─A)| = |(X─B)|) ∧\n  (∀ (X : Point), |(X─A)| = |(X─B)| → X.onLine L)\n:= by\n",
        "formal_proof": "theorem perpBisector_property : ∀ (A B : Point) (L : Line),\n  perpBisector A B L →\n  (∀ (X : Point), X.onLine L → |(X─A)| = |(X─B)|) ∧\n  (∀ (X : Point), |(X─A)| = |(X─B)| → X.onLine L)\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpBisector_construction",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpBisector_construction :\n∀ (a b p q : Point) (L : Line),\n(|(a─p)| = |(b─p)|) ∧ (|(a─q)| = |(b─q)|) ∧ distinctPointsOnLine p q L\n→ perpBisector a b L := by\n",
        "formal_proof": "theorem perpBisector_construction :\n∀ (a b p q : Point) (L : Line),\n(|(a─p)| = |(b─p)|) ∧ (|(a─q)| = |(b─q)|) ∧ distinctPointsOnLine p q L\n→ perpBisector a b L := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpBisector_equiv",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpBisector_equiv : ∀ (A B : Point) (L: Line),\nperpBisector A B L ↔ ∃ (P :Point) (AB : Line), midpoint A P B ∧ perpLine AB L ∧ distinctPointsOnLine A B AB := by\n",
        "formal_proof": "theorem perpBisector_equiv : ∀ (A B : Point) (L: Line),\nperpBisector A B L ↔ ∃ (P :Point) (AB : Line), midpoint A P B ∧ perpLine AB L ∧ distinctPointsOnLine A B AB := by\n  sorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "between_fourpoint",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem between_fourpoint: ∀(A B C D: Point), between A B C ∧ between B C D ∧ between C D E → between A C E := by\n",
        "formal_proof": "theorem between_fourpoint: ∀(A B C D: Point), between A B C ∧ between B C D ∧ between C D E → between A C E := by\n  euclid_intros\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "between_zeroAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem between_zeroAngle : ∀ (A B C : Point), between A B C → ∠B:A:C = 0 := by\n",
        "formal_proof": "theorem between_zeroAngle : ∀ (A B C : Point), between A B C → ∠B:A:C = 0 := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "between_straightAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem between_straightAngle : ∀ (A B C : Point), between A B C → ∠A:B:C = ∟  + ∟ := by\n",
        "formal_proof": "theorem between_straightAngle : ∀ (A B C : Point), between A B C → ∠A:B:C = ∟  + ∟ := by\n  sorry\n\n--Triangle\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "triangle_anglePositive",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem triangle_anglePositive : ∀(A B C : Point) , triangle A B C → ∠A:B:C > 0 ∧ ∠A:C:B >0 ∧ ∠C:A:B >0 := by\n",
        "formal_proof": "theorem triangle_anglePositive : ∀(A B C : Point) , triangle A B C → ∠A:B:C > 0 ∧ ∠A:C:B >0 ∧ ∠C:A:B >0 := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "triangle_angleSum",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem triangle_angleSum : ∀(A B C : Point) , triangle A B C → ∠A:B:C +∠B:C:A + ∠C:A:B = ∟ + ∟ := by\n",
        "formal_proof": "theorem triangle_angleSum : ∀(A B C : Point) , triangle A B C → ∠A:B:C +∠B:C:A + ∠C:A:B = ∟ + ∟ := by\n  euclid_intros\n  euclid_assert ¬ (between A B C)\n  euclid_assert A ≠ B\n  euclid_apply line_from_points A B as AB\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "triangle_exteriorAngle",
        "using_lemmas": [
            "triangle_angleSum",
            "supplementaryAngle_line"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem triangle_exteriorAngle : ∀ (a b c d: Point), (triangle a b c) ∧ (between a b d) → ∠d:b:c = ∠b:c:a + ∠c:a:b := by\n",
        "formal_proof": "theorem triangle_exteriorAngle : ∀ (a b c d: Point), (triangle a b c) ∧ (between a b d) → ∠d:b:c = ∠b:c:a + ∠c:a:b := by\n  euclid_intros\n  euclid_apply triangle_angleSum a b c\n  --euclid_assert ∠c:b:d +∠c:b:a = ∟ + ∟\n  euclid_apply supplementaryAngle_line c a b d\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "isoTriangle_eqAngle",
        "using_lemmas": [
            "exists_midpoint",
            "line_from_points",
            "Triangle.congruent_property"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem isoTriangle_eqAngle : ∀ (A B C : Point), isoTriangle A B C → ∠ A:B:C = ∠A:C:B := by\n",
        "formal_proof": "theorem isoTriangle_eqAngle : ∀ (A B C : Point), isoTriangle A B C → ∠ A:B:C = ∠A:C:B := by\n  euclid_intros\n  euclid_apply exists_midpoint B C as D\n  euclid_apply line_from_points B C as BC\n  euclid_assert A ≠ D\n  euclid_assert triangle D A B\n  euclid_assert triangle D A C\n  euclid_assert Triangle.congruent_test (△ D:A:B) (△ D:A:C)\n  euclid_apply Triangle.congruent_property (△ D:A:B) (△ D:A:C)\n  euclid_assert ∠D:B:A = ∠D:C:A\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "eqside_eqAngle",
        "using_lemmas": [
            "isoTriangle_eqAngle",
            "between_zeroAngle",
            "between_zeroAngle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem eqside_eqAngle :∀ (O A B : Point), |(O─A)|=|(O─B)| ∧ (A ≠ B) → ∠O:A:B = ∠O:B:A := by\n",
        "formal_proof": "theorem eqside_eqAngle :∀ (O A B : Point), |(O─A)|=|(O─B)| ∧ (A ≠ B) → ∠O:A:B = ∠O:B:A := by\n  euclid_intros\n  by_cases triangle O A B\n  · euclid_assert isoTriangle O A B\n    euclid_apply isoTriangle_eqAngle O A B\n    euclid_finish\n  · euclid_assert between A O B\n    euclid_apply between_zeroAngle A O B\n    euclid_apply between_zeroAngle B O A\n    euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "eqAngle_isoTriangle",
        "using_lemmas": [
            "line_from_points",
            "point_not_onLine",
            "exists_foot"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem eqAngle_isoTriangle : ∀ (a b c : Point),\n  (triangle a b c) ∧ (∠ b:a:c = ∠ a:b:c)\n  → |(b─c)| = |(a─c)| := by\n",
        "formal_proof": "theorem eqAngle_isoTriangle : ∀ (a b c : Point),\n  (triangle a b c) ∧ (∠ b:a:c = ∠ a:b:c)\n  → |(b─c)| = |(a─c)| := by\n  euclid_intros\n  euclid_apply line_from_points b c as BC\n  euclid_apply point_not_onLine a b c BC\n  euclid_apply exists_foot a b c BC as d\n  euclid_assert a ≠ d\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "isoTriangle_threeLine_concidence",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem isoTriangle_threeLine_concidence : ∀ (a b c d: Point),\n  isoTriangle a b c ∧ coll c b d →\n  (midpoint b d c ∨ ∠a:d:b = ∟ ∨ ∠a:d:c = ∟ ∨ ∠d:a:b = ∠ d:a:c) →\n  (midpoint b d c ∧  ∠a:d:b = ∟ ∧  ∠a:d:c = ∟ ∧  ∠d:a:b = ∠ d:a:c)\n:= by\n",
        "formal_proof": "theorem isoTriangle_threeLine_concidence : ∀ (a b c d: Point),\n  isoTriangle a b c ∧ coll c b d →\n  (midpoint b d c ∨ ∠a:d:b = ∟ ∨ ∠a:d:c = ∟ ∨ ∠d:a:b = ∠ d:a:c) →\n  (midpoint b d c ∧  ∠a:d:b = ∟ ∧  ∠a:d:c = ∟ ∧  ∠d:a:b = ∠ d:a:c)\n:= by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "pythagorean",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem pythagorean : ∀ (a b c: Point) (AB BC AC : Line),\n  formTriangle a b c AB BC AC ∧ (∠ b:a:c : ℝ) = ∟ →\n  |(b─c)| * |(b─c)| = |(b─a)| * |(b─a)| + |(a─c)| * |(a─c)| :=\nby\n  sorry\n\n",
        "formal_proof": "theorem pythagorean : ∀ (a b c: Point) (AB BC AC : Line),\n  formTriangle a b c AB BC AC ∧ (∠ b:a:c : ℝ) = ∟ →\n  |(b─c)| * |(b─c)| = |(b─a)| * |(b─a)| + |(a─c)| * |(a─c)| :=\nby\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "pythagorean_point",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem pythagorean_point : ∀ (a b c: Point), (triangle a b c) ∧ (∠ b:a:c : ℝ) = ∟ →\n  |(b─c)| * |(b─c)| = |(b─a)| * |(b─a)| + |(a─c)| * |(a─c)| := by\n",
        "formal_proof": "theorem pythagorean_point : ∀ (a b c: Point), (triangle a b c) ∧ (∠ b:a:c : ℝ) = ∟ →\n  |(b─c)| * |(b─c)| = |(b─a)| * |(b─a)| + |(a─c)| * |(a─c)| := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "triangle_side_angle_inequality",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem triangle_side_angle_inequality : ∀ (a b c: Point),\n  (triangle a b c) ∧ (|(b─c)| > |(a─c)|)\n  → ∠ b:a:c > ∠ a:b:c := by\n",
        "formal_proof": "theorem triangle_side_angle_inequality : ∀ (a b c: Point),\n  (triangle a b c) ∧ (|(b─c)| > |(a─c)|)\n  → ∠ b:a:c > ∠ a:b:c := by\nsorry\n\n\naxiom triangle_inequality : ∀ (a b c : Point), triangle a b c →\n|(a─b)| < |(b─c)| + |(c─a)|\n\naxiom triangle_inequality_le : ∀ (a b c : Point),\n|(a─b)| ≤  |(b─c)| + |(c─a)|\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "triangle_ineqaulity_eql",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem triangle_ineqaulity_eql : ∀ (a b c : Point), |(a─b)| = |(b─c)| + |(c─a)| → between b c a := by\n",
        "formal_proof": "theorem triangle_ineqaulity_eql : ∀ (a b c : Point), |(a─b)| = |(b─c)| + |(c─a)| → between b c a := by\n  sorry\n\n\n--Parallel\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallel_eqAlternateAngles",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallel_eqAlternateAngles :\n∀ (L M T : Line) (A B C D : Point),\n  (¬ L.intersectsLine M) ∧\n  twoLinesIntersectAtPoint L T A ∧\n  twoLinesIntersectAtPoint M T B ∧\n  C.onLine L ∧\n  D.onLine M ∧ A ≠ C ∧ D ≠ B ∧\n  C.opposingSides D T\n  → ∠ C:A:B = ∠ A:B:D\n:= by\n",
        "formal_proof": "theorem parallel_eqAlternateAngles :\n∀ (L M T : Line) (A B C D : Point),\n  (¬ L.intersectsLine M) ∧\n  twoLinesIntersectAtPoint L T A ∧\n  twoLinesIntersectAtPoint M T B ∧\n  C.onLine L ∧\n  D.onLine M ∧ A ≠ C ∧ D ≠ B ∧\n  C.opposingSides D T\n  → ∠ C:A:B = ∠ A:B:D\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallel_SupplementConsecutiveAngles",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallel_SupplementConsecutiveAngles :\n∀ (L M T : Line) (A B C D : Point),\n  (¬ L.intersectsLine M) ∧\n  twoLinesIntersectAtPoint L T A ∧\n  twoLinesIntersectAtPoint M T B ∧\n  C.onLine L ∧\n  D.onLine M ∧\n  C.sameSide D T\n  → ∠ C:A:B + ∠ A:B:D = ∟ + ∟\n:= by\n",
        "formal_proof": "theorem parallel_SupplementConsecutiveAngles :\n∀ (L M T : Line) (A B C D : Point),\n  (¬ L.intersectsLine M) ∧\n  twoLinesIntersectAtPoint L T A ∧\n  twoLinesIntersectAtPoint M T B ∧\n  C.onLine L ∧\n  D.onLine M ∧\n  C.sameSide D T\n  → ∠ C:A:B + ∠ A:B:D = ∟ + ∟\n:= by\nsorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpLine_perpLine_parallel",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpLine_perpLine_parallel : ∀ (L1 L2 M : Line),\n  (perpLine L1 M) ∧ (perpLine L2 M) →\n  ¬(L1.intersectsLine L2) :=\nby sorry\n\n",
        "formal_proof": "theorem perpLine_perpLine_parallel : ∀ (L1 L2 M : Line),\n  (perpLine L1 M) ∧ (perpLine L2 M) →\n  ¬(L1.intersectsLine L2) :=\nby sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpLine_parallel_perpLine",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpLine_parallel_perpLine:\n  ∀ (M N L : Line),\n    (perpLine M N ∧ ¬L.intersectsLine M) →\n    perpLine L N :=\nby\n  sorry\n\n\n\n--Circle\n",
        "formal_proof": "theorem perpLine_parallel_perpLine:\n  ∀ (M N L : Line),\n    (perpLine M N ∧ ¬L.intersectsLine M) →\n    perpLine L N :=\nby\n  sorry\n\n\n\n--Circle\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "eqChord_eqCentralAngle",
        "using_lemmas": [
            "angle_coincide_zero",
            "angle_coincide_zero",
            "triangle_ineqaulity_eql",
            "Triangle.congruent_property"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem eqChord_eqCentralAngle : ∀ (a b c d o: Point) (O : Circle), a.onCircle O ∧ b.onCircle O ∧ c.onCircle O ∧ d.onCircle O ∧  o.isCentre O ∧ |(a─b)| = |(c─d)| → ∠a:o:b =∠ c:o:d := by\n",
        "formal_proof": "theorem eqChord_eqCentralAngle : ∀ (a b c d o: Point) (O : Circle), a.onCircle O ∧ b.onCircle O ∧ c.onCircle O ∧ d.onCircle O ∧  o.isCentre O ∧ |(a─b)| = |(c─d)| → ∠a:o:b =∠ c:o:d := by\n  euclid_intros\n  by_cases h : a = b\n  · euclid_assert c = d\n    euclid_apply angle_coincide_zero b o\n    euclid_apply angle_coincide_zero d o\n    euclid_finish\n  · -- Case a ≠ b\n    euclid_assert c ≠ d\n    by_cases h2 : coll a o b\n    · euclid_assert between a o b\n      euclid_assert |(a─b)| = |(a─o)| + |(o─b)|\n      euclid_assert |(c─d)| = |(c─o)| + |(o─d)|\n      euclid_apply triangle_ineqaulity_eql c d o\n      euclid_finish\n    · euclid_assert (△ a:o:b).congruent_test (△ c:o:d)\n      euclid_apply Triangle.congruent_property (△ a:o:b) (△ c:o:d)\n      euclid_finish\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "threePoints_existCircle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem threePoints_existCircle : ∀ (A B C : Point),\n  triangle A B C →\n  ∃ (Ω : Circle),\n    (A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω) :=\nby sorry\n\n",
        "formal_proof": "theorem threePoints_existCircle : ∀ (A B C : Point),\n  triangle A B C →\n  ∃ (Ω : Circle),\n    (A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω) :=\nby sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "eqChord_eqInsctribedAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem eqChord_eqInsctribedAngle : ∀\n(A B C A' B' C' : Point) (Ω : Circle), distinctThreePoints A B C ∧ distinctThreePoints A' B' C' ∧\n  A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω\n  ∧ A'.onCircle Ω ∧ B'.onCircle Ω ∧ C'.onCircle Ω\n  ∧ (|(A─C)| = |(A'─C')|)\n  → ∠ A:B:C = ∠ A':B':C' ∨ ∠ A:B:C + ∠ A':B':C' = ∟ + ∟\n:= by\n",
        "formal_proof": "theorem eqChord_eqInsctribedAngle : ∀\n(A B C A' B' C' : Point) (Ω : Circle), distinctThreePoints A B C ∧ distinctThreePoints A' B' C' ∧\n  A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω\n  ∧ A'.onCircle Ω ∧ B'.onCircle Ω ∧ C'.onCircle Ω\n  ∧ (|(A─C)| = |(A'─C')|)\n  → ∠ A:B:C = ∠ A':B':C' ∨ ∠ A:B:C + ∠ A':B':C' = ∟ + ∟\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "eqInscribedAngle_eqChord",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem eqInscribedAngle_eqChord : ∀\n(A B C A' B' C' : Point) (Ω : Circle), distinctThreePoints A B C ∧ distinctThreePoints A' B' C' ∧\n  A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω\n  ∧ A'.onCircle Ω ∧ B'.onCircle Ω ∧ C'.onCircle Ω\n  ∧ ∠A:B:C = ∠ A':B':C' ∨ ∠ A:B:C + ∠ A':B':C' = ∟ + ∟\n  → |(A─C)| = |(A'─C')|\n:= by\n",
        "formal_proof": "theorem eqInscribedAngle_eqChord : ∀\n(A B C A' B' C' : Point) (Ω : Circle), distinctThreePoints A B C ∧ distinctThreePoints A' B' C' ∧\n  A.onCircle Ω ∧ B.onCircle Ω ∧ C.onCircle Ω\n  ∧ A'.onCircle Ω ∧ B'.onCircle Ω ∧ C'.onCircle Ω\n  ∧ ∠A:B:C = ∠ A':B':C' ∨ ∠ A:B:C + ∠ A':B':C' = ∟ + ∟\n  → |(A─C)| = |(A'─C')|\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "intersecting_chord",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem intersecting_chord : ∀ (A B C D E : Point) (O: Circle),\n  A.onCircle O ∧ B.onCircle O ∧ C.onCircle O ∧ D.onCircle O ∧\n  distinctFourPoints A B C D ∧\n  between A E B ∧ between C E D → |(A─E)| * |(E─B)| = |(C─E)| * |(E─D)|:= by\n",
        "formal_proof": "theorem intersecting_chord : ∀ (A B C D E : Point) (O: Circle),\n  A.onCircle O ∧ B.onCircle O ∧ C.onCircle O ∧ D.onCircle O ∧\n  distinctFourPoints A B C D ∧\n  between A E B ∧ between C E D → |(A─E)| * |(E─B)| = |(C─E)| * |(E─D)|:= by\n  sorry\n\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "inscribedAngle_eq_tangentAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem inscribedAngle_eq_tangentAngle : ∀ (A B C D : Point) (Ω : Circle) (AB BC CAL : Line),\n  (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ formTriangle A B C AB BC CA ∧\n  distinctPointsOnLine A D L ∧ tangentAtPoint L Ω A ∧ B.sameSide D AC\n  → ∠ B:A:D = ∠ B:C:A :=\nby sorry\n\n",
        "formal_proof": "theorem inscribedAngle_eq_tangentAngle : ∀ (A B C D : Point) (Ω : Circle) (AB BC CAL : Line),\n  (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ formTriangle A B C AB BC CA ∧\n  distinctPointsOnLine A D L ∧ tangentAtPoint L Ω A ∧ B.sameSide D AC\n  → ∠ B:A:D = ∠ B:C:A :=\nby sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "intersecting_circles_perpendicular_bisector",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem intersecting_circles_perpendicular_bisector :\n  ∀ (C1 C2 : Circle) (O1 O2 A B : Point) (L : Line),\n  (circlesIntersectsAtTwoPoints C1 C2 O1 O2)\n  ∧ (O1.onLine L)\n  ∧ (O2.onLine L)\n  → perpBisector A B L :=\nby sorry\n\n\n",
        "formal_proof": "theorem intersecting_circles_perpendicular_bisector :\n  ∀ (C1 C2 : Circle) (O1 O2 A B : Point) (L : Line),\n  (circlesIntersectsAtTwoPoints C1 C2 O1 O2)\n  ∧ (O1.onLine L)\n  ∧ (O2.onLine L)\n  → perpBisector A B L :=\nby sorry\n\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "diameter_longest",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem diameter_longest : ∀(a b c d: Point) (C: Circle), (diameter a b C) ∧ (c.onCircle C) ∧ (d.onCircle C) → |(a─b)| ≥ |(c─d)| := by\n",
        "formal_proof": "theorem diameter_longest : ∀(a b c d: Point) (C: Circle), (diameter a b C) ∧ (c.onCircle C) ∧ (d.onCircle C) → |(a─b)| ≥ |(c─d)| := by\n  euclid_intros\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "perpendicular_radius_tangent",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perpendicular_radius_tangent : ∀\n  (a b : Point) (AB L : Line) (C : Circle),\n  distinctPointsOnLine a b AB ∧\n  b.isCentre C ∧\n  a.onCircle C ∧\n  twoLinesIntersectAtPoint AB L a ∧\n  perpLine AB L\n  → tangentLine L C := by\n",
        "formal_proof": "theorem perpendicular_radius_tangent : ∀\n  (a b : Point) (AB L : Line) (C : Circle),\n  distinctPointsOnLine a b AB ∧\n  b.isCentre C ∧\n  a.onCircle C ∧\n  twoLinesIntersectAtPoint AB L a ∧\n  perpLine AB L\n  → tangentLine L C := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "inscribed_formtriangle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem inscribed_formtriangle : ∀ (A B C O : Point) (Γ : Circle),\n  A.onCircle Γ ∧ B.onCircle Γ ∧ C.onCircle Γ ∧ O.isCentre Γ ∧ A ≠ B ∧ B ≠ C ∧ C ≠ A\n  → triangle A B C := by\n",
        "formal_proof": "theorem inscribed_formtriangle : ∀ (A B C O : Point) (Γ : Circle),\n  A.onCircle Γ ∧ B.onCircle Γ ∧ C.onCircle Γ ∧ O.isCentre Γ ∧ A ≠ B ∧ B ≠ C ∧ C ≠ A\n  → triangle A B C := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "inscribed_angle_measure",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem inscribed_angle_measure : ∀ (A B C O : Point) (Γ : Circle),\n  A.onCircle Γ ∧ B.onCircle Γ ∧ C.onCircle Γ ∧ O.isCentre Γ ∧ A ≠ B ∧ B ≠ C ∧ C ≠ A\n  → 2 * ∠ A:B:C = ∠ A:O:C := by\n",
        "formal_proof": "theorem inscribed_angle_measure : ∀ (A B C O : Point) (Γ : Circle),\n  A.onCircle Γ ∧ B.onCircle Γ ∧ C.onCircle Γ ∧ O.isCentre Γ ∧ A ≠ B ∧ B ≠ C ∧ C ≠ A\n  → 2 * ∠ A:B:C = ∠ A:O:C := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "tangent_circles_line_of_centers",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem tangent_circles_line_of_centers\n  : ∀ (C1 C2 : Circle) (O1 O2 T : Point),\n    O1.isCentre C1 ∧\n    O2.isCentre C2 ∧\n    T.onCircle C1 ∧\n    T.onCircle C2 ∧\n    (∀ X : Point, X.onCircle C1 ∧ X.onCircle C2 → X = T)\n    → coll O1 O2 T\n  := by\n",
        "formal_proof": "theorem tangent_circles_line_of_centers\n  : ∀ (C1 C2 : Circle) (O1 O2 T : Point),\n    O1.isCentre C1 ∧\n    O2.isCentre C2 ∧\n    T.onCircle C1 ∧\n    T.onCircle C2 ∧\n    (∀ X : Point, X.onCircle C1 ∧ X.onCircle C2 → X = T)\n    → coll O1 O2 T\n  := by\nsorry\n\n\n--Quadrilateral\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallelogram_tests",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallelogram_tests : ∀\n  (A B C D : Point)\n  (AB BC CD DA AC BD : Line),\n  (formQuadrilateral A B C D AB BC CD DA) ∧\n  (\n    (|(A─B)| = |(C─D)| ∧ |(B─C)| = |(D─A)|)\n    ∨\n    (|(A─B)| = |(C─D)| ∧ ¬ AB.intersectsLine CD)\n    ∨\n    (∃ O : Point, twoLinesIntersectAtPoint AC BD O ∧ midpoint A O C ∧ midpoint B O D)\n  )\n  →\n  (parallelogram A B C D AB BC CD DA)\n:= by\n",
        "formal_proof": "theorem parallelogram_tests : ∀\n  (A B C D : Point)\n  (AB BC CD DA AC BD : Line),\n  (formQuadrilateral A B C D AB BC CD DA) ∧\n  (\n    (|(A─B)| = |(C─D)| ∧ |(B─C)| = |(D─A)|)\n    ∨\n    (|(A─B)| = |(C─D)| ∧ ¬ AB.intersectsLine CD)\n    ∨\n    (∃ O : Point, twoLinesIntersectAtPoint AC BD O ∧ midpoint A O C ∧ midpoint B O D)\n  )\n  →\n  (parallelogram A B C D AB BC CD DA)\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallelogram_eqside",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallelogram_eqside : ∀ (A B C D : Point) (AB BC CD DA : Line),\n  (formQuadrilateral A B C D AB BC CD DA ∧\n   ¬(∃ X : Point, twoLinesIntersectAtPoint AB DC X) ∧\n   ¬(∃ X : Point, twoLinesIntersectAtPoint BC DA X))\n  → (|(A─B)| = |(C─D)| ∧ |(B─C)| = |(D─A)|) := by\n",
        "formal_proof": "theorem parallelogram_eqside : ∀ (A B C D : Point) (AB BC CD DA : Line),\n  (formQuadrilateral A B C D AB BC CD DA ∧\n   ¬(∃ X : Point, twoLinesIntersectAtPoint AB DC X) ∧\n   ¬(∃ X : Point, twoLinesIntersectAtPoint BC DA X))\n  → (|(A─B)| = |(C─D)| ∧ |(B─C)| = |(D─A)|) := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallelogram_eqAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallelogram_eqAngle :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  (formQuadrilateral A B C D AB BC CD DA)\n  ∧ (¬ AB.intersectsLine CD)\n  ∧ (¬ DA.intersectsLine BC)\n  → ∠D:A:B = ∠B:C:D ∧ ∠A:B:C = ∠C:D:A\n:= by\n",
        "formal_proof": "theorem parallelogram_eqAngle :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  (formQuadrilateral A B C D AB BC CD DA)\n  ∧ (¬ AB.intersectsLine CD)\n  ∧ (¬ DA.intersectsLine BC)\n  → ∠D:A:B = ∠B:C:D ∧ ∠A:B:C = ∠C:D:A\n:= by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "parallelogram_diagonals_bisect",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem parallelogram_diagonals_bisect :\n∀ (A B C D E : Point) (AB BC CD DA AC BD : Line),\n  (parallelogram A B C D AB BC CD DA)\n  ∧ distinctPointsOnLine A C AC\n  ∧ distinctPointsOnLine B D BD\n  ∧ (twoLinesIntersectAtPoint AC BD E)\n  → (midpoint A E C ∧ midpoint B E D) := by\n",
        "formal_proof": "theorem parallelogram_diagonals_bisect :\n∀ (A B C D E : Point) (AB BC CD DA AC BD : Line),\n  (parallelogram A B C D AB BC CD DA)\n  ∧ distinctPointsOnLine A C AC\n  ∧ distinctPointsOnLine B D BD\n  ∧ (twoLinesIntersectAtPoint AC BD E)\n  → (midpoint A E C ∧ midpoint B E D) := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "rhombus_angleBisects",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem rhombus_angleBisects :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  rhombus A B C D AB BC CD DA →\n     (∠B:A:C = ∠C:A:D\n     ∧ ∠B:C:A = ∠A:C:D\n     ∧ ∠A:B:D = ∠D:B:C\n     ∧ ∠C:D:B = ∠B:D:A) := by\n",
        "formal_proof": "theorem rhombus_angleBisects :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  rhombus A B C D AB BC CD DA →\n     (∠B:A:C = ∠C:A:D\n     ∧ ∠B:C:A = ∠A:C:D\n     ∧ ∠A:B:D = ∠D:B:C\n     ∧ ∠C:D:B = ∠B:D:A) := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "rhombus_angleBisects_perpendicular",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem rhombus_angleBisects_perpendicular :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  rhombus A B C D AB BC CD DA ∧ distinctPointsOnLine A C AC ∧ distinctPointsOnLine B D BD →\n    perpLine AC BD := by\n",
        "formal_proof": "theorem rhombus_angleBisects_perpendicular :\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  rhombus A B C D AB BC CD DA ∧ distinctPointsOnLine A C AC ∧ distinctPointsOnLine B D BD →\n    perpLine AC BD := by\nsorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "circumscribed_quadrilateral_eqsumside",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem circumscribed_quadrilateral_eqsumside :\n  ∀ (A B C D : Point) (AB BC CD DA : Line) (Ω : Circle),\n    (formQuadrilateral A B C D AB BC CD DA)\n    ∧ (tangentLine AB Ω)\n    ∧ (tangentLine BC Ω)\n    ∧ (tangentLine CD Ω)\n    ∧ (tangentLine DA Ω)\n    → (|(A─B)| + |(C─D)| = |(B─C)| + |(D─A)|) :=\nby\n  sorry\n\n",
        "formal_proof": "theorem circumscribed_quadrilateral_eqsumside :\n  ∀ (A B C D : Point) (AB BC CD DA : Line) (Ω : Circle),\n    (formQuadrilateral A B C D AB BC CD DA)\n    ∧ (tangentLine AB Ω)\n    ∧ (tangentLine BC Ω)\n    ∧ (tangentLine CD Ω)\n    ∧ (tangentLine DA Ω)\n    → (|(A─B)| + |(C─D)| = |(B─C)| + |(D─A)|) :=\nby\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "cyclic_test (A B C D",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem cyclic_test (A B C D: Point) (AB BC CD DA :Line) : (formQuadrilateral A B C D AB BC CD DA) ∧ (\n  (∠ A:B:D = ∠ A:C:D) ∨\n  (∠ D:A:C = ∠ D:B:C) ∨\n  (∠ A:D:B = ∠ A:C:B) ∨\n  (∠ B:D:C = ∠ B:A:C) ∨\n  (∠ A:D:C + ∠A:B:C = ∟ + ∟) ∨\n  (∠ D:A:B + ∠D:C:B = ∟ + ∟)) → ∃ (O: Circle), cyclicQuadrilateral A B C D AB BC CD DA O := by\n",
        "formal_proof": "theorem cyclic_test (A B C D: Point) (AB BC CD DA :Line) : (formQuadrilateral A B C D AB BC CD DA) ∧ (\n  (∠ A:B:D = ∠ A:C:D) ∨\n  (∠ D:A:C = ∠ D:B:C) ∨\n  (∠ A:D:B = ∠ A:C:B) ∨\n  (∠ B:D:C = ∠ B:A:C) ∨\n  (∠ A:D:C + ∠A:B:C = ∟ + ∟) ∨\n  (∠ D:A:B + ∠D:C:B = ∟ + ∟)) → ∃ (O: Circle), cyclicQuadrilateral A B C D AB BC CD DA O := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "cyclic_property (A B C D",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem cyclic_property (A B C D: Point) (AB BC CD DA :Line) (O: Circle): cyclicQuadrilateral A B C D AB BC CD DA O →\n  (∠ A:B:D = ∠ A:C:D) ∧\n  (∠ D:A:C = ∠ D:B:C) ∧\n  (∠ A:D:B = ∠ A:C:B) ∧\n  (∠ B:D:C = ∠ B:A:C) ∧\n  (∠ A:D:C + ∠A:B:C = ∟ + ∟) ∧\n  (∠ D:A:B + ∠D:A:C = ∟ + ∟)\n  :=by\n  sorry\n\n",
        "formal_proof": "theorem cyclic_property (A B C D: Point) (AB BC CD DA :Line) (O: Circle): cyclicQuadrilateral A B C D AB BC CD DA O →\n  (∠ A:B:D = ∠ A:C:D) ∧\n  (∠ D:A:C = ∠ D:B:C) ∧\n  (∠ A:D:B = ∠ A:C:B) ∧\n  (∠ B:D:C = ∠ B:A:C) ∧\n  (∠ A:D:C + ∠A:B:C = ∟ + ∟) ∧\n  (∠ D:A:B + ∠D:A:C = ∟ + ∟)\n  :=by\n  sorry\n\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "isoTrapezoid_eqAngle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem isoTrapezoid_eqAngle:\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  trapezoid A B C D AB BC CD DA ∧\n  (|(B─C)| = |(D─A)|)\n  → (∠A:B:C = ∠D:C:B) ∧ (∠B:A:D = ∠C:D:A) := by\n",
        "formal_proof": "theorem isoTrapezoid_eqAngle:\n  ∀ (A B C D : Point) (AB BC CD DA : Line),\n  trapezoid A B C D AB BC CD DA ∧\n  (|(B─C)| = |(D─A)|)\n  → (∠A:B:C = ∠D:C:B) ∧ (∠B:A:D = ∠C:D:A) := by\nsorry\n\n--Algebra\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "ratio_transfer",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem ratio_transfer : ∀ (a b c d : ℝ), a / b = c / d  → a / c = b / d := by\n",
        "formal_proof": "theorem ratio_transfer : ∀ (a b c d : ℝ), a / b = c / d  → a / c = b / d := by\n  sorry\n",
        "source": "LeanGeo/Theorem_proof.lean"
    },
    {
        "name": "self_fullAngle",
        "using_lemmas": [
            "triangle_angleSum",
            "triangle_angleSum",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem self_fullAngle : ∀ (A B C O : Point) (AB BC CA: Line), formTriangle A B C AB BC CA ∧ insideTriangle O A B C AB BC CA → ∠A:O:C + ∠ C:O:B + ∠ B:O:A = ∟ + ∟ +  ∟ + ∟ := by\n",
        "formal_proof": "theorem self_fullAngle : ∀ (A B C O : Point) (AB BC CA: Line), formTriangle A B C AB BC CA ∧ insideTriangle O A B C AB BC CA → ∠A:O:C + ∠ C:O:B + ∠ B:O:A = ∟ + ∟ +  ∟ + ∟ := by\n  euclid_intros\n  euclid_apply triangle_angleSum A O B\n  euclid_apply triangle_angleSum C O B\n  euclid_apply triangle_angleSum A O C\n  euclid_apply triangle_angleSum A B C\n  euclid_finish\n\n--Theorem 1.3 (Inscribed Angle Theorem). If ∠A C B is inscribed in a circle, then it subtends an arc with measure 2∠A C B.\n--Draw in O C. Set α = ∠A C O and β = ∠B C O, and let θ = α + β. Because A O = C O we have ∠O A C = ∠O C A = α, so ∠A O C = 180° − 2α. Similarly ∠B O C = 180° − 2β. Hence ∠A O B = 360° − [(180° − 2α) + (180° − 2β)] = 2θ.\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "inscribed_angle_theorem",
        "using_lemmas": [
            "self_fullAngle",
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "isoTriangle_eqAngle",
            "isoTriangle_eqAngle",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inscribed_angle_theorem :\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (insideTriangle O A B C AB BC CA) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n",
        "formal_proof": "theorem inscribed_angle_theorem :\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (insideTriangle O A B C AB BC CA) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n  euclid_intros\n  euclid_apply self_fullAngle A B C O AB BC CA\n  euclid_apply line_from_points O C as OC\n  euclid_apply line_from_points O B as OB\n  euclid_apply line_from_points O A as OA\n  euclid_apply isoTriangle_eqAngle O A C\n  euclid_apply isoTriangle_eqAngle O C B\n  euclid_apply triangle_angleSum A O C\n  euclid_apply triangle_angleSum C O B\n  euclid_finish\n\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "inside_triangle_opposingsides",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inside_triangle_opposingsides :  ∀ (A B C I : Point) (AB BC CA BI : Line), (formTriangle A B C AB BC CA) ∧ (insideTriangle I A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) → A.opposingSides C BI := by\n",
        "formal_proof": "theorem inside_triangle_opposingsides :  ∀ (A B C I : Point) (AB BC CA BI : Line), (formTriangle A B C AB BC CA) ∧ (insideTriangle I A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) → A.opposingSides C BI := by\n  euclid_intros\n  euclid_finish\n\n\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "opposingsides_inside_triangle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n",
        "formal_proof": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n  euclid_intros\n  sorry\n\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "angleBisector_opposingsides",
        "using_lemmas": [
            "line_from_points",
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n",
        "formal_proof": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n  euclid_intros\n  by_contra\n  euclid_apply line_from_points A C as AC\n  euclid_apply line_from_points A B as AB\n  euclid_finish\n\n\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "incenter_inside",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "opposingsides_inside_triangle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n",
        "formal_proof": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n  euclid_intros\n  euclid_apply line_from_points A I as AI\n  euclid_apply line_from_points B I as BI\n  euclid_apply line_from_points C I as CI\n  euclid_apply angleBisector_opposingsides A B C I AI\n  euclid_apply angleBisector_opposingsides C A B I CI\n  euclid_apply angleBisector_opposingsides B C A I BI\n  euclid_apply opposingsides_inside_triangle A B C I AB BC CA AI BI CI\n  euclid_finish\n\n--Example 1.4. If I is the incenter of ΔA B C then ∠B I C = 90° + ½A.\n--原则：让题面叙述变得简单？\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "incenter_angle",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "incenter_inside",
            "self_fullAngle",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem incenter_angle : ∀ (A B C I : Point), (triangle A B C) ∧ (inCentre I A B C) → ∠B:I:C = ∟ + ∠B:A:C / 2 := by\n",
        "formal_proof": "theorem incenter_angle : ∀ (A B C I : Point), (triangle A B C) ∧ (inCentre I A B C) → ∠B:I:C = ∟ + ∠B:A:C / 2 := by\n  euclid_intros\n  euclid_apply line_from_points A B as AB\n  euclid_apply line_from_points A C as CA\n  euclid_apply line_from_points B C as BC\n  --euclid_assert formTriangle A B C AB BC CA\n  euclid_apply incenter_inside A B C I AB BC CA\n  --euclid_apply self_fullAngle A B C I AB BC CA\n  euclid_apply triangle_angleSum I B C\n  euclid_apply triangle_angleSum A B C\n  --euclid_assert ∠A:B:C = 2 * ∠I:B:C\n  --euclid_assert ∠A:C:B = 2 * ∠I:C:B\n  euclid_finish\n",
        "source": "LeanGeo/EvanChenTheorem.lean"
    },
    {
        "name": "problem_1_7",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem problem_1_7 : ∀ (A B C O H : Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) ∧\n  (perpPoint A H B C) ∧\n  (perpPoint B H A C) →\n  ∠B:A:H = ∠C:A:O := by\n",
        "formal_proof": "theorem problem_1_7 : ∀ (A B C O H : Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) ∧\n  (perpPoint A H B C) ∧\n  (perpPoint B H A C) →\n  ∠B:A:H = ∠C:A:O := by\nsorry\n",
        "source": "LeanGeo/Exercise/1-7.lean"
    },
    {
        "name": "Example_1_1",
        "using_lemmas": [
            "intersection_lines",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Example_1_1 :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ Y:Z:W = ∟ * 7/9) := by\n",
        "formal_proof": "theorem Example_1_1 :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ Y:Z:W = ∟ * 7/9) := by\n  euclid_intros\n  euclid_apply intersection_lines XZ WY as P\n  --euclid_assert ∠Z:P:Y = ∟\n  --euclid_assert triangle P Y Z\n  euclid_apply triangle_angleSum P Y Z\n  --euclid_assert ∠Y:Z:P = 4/9 * ∟\n  euclid_finish\n\n",
        "source": "LeanGeo/Exercise/1-1.lean"
    },
    {
        "name": "Example_1_1a",
        "using_lemmas": [
            "intersection_lines",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Example_1_1a :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ W:Z:Y = ∟ * 7/9) := by\n",
        "formal_proof": "theorem Example_1_1a :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ W:Z:Y = ∟ * 7/9) := by\n  euclid_intros\n  euclid_apply intersection_lines XZ WY as P\n  --euclid_assert ∠Z:P:Y = ∟\n  --euclid_assert triangle P Y Z\n  euclid_apply triangle_angleSum P Y Z\n  --euclid_assert ∠Y:Z:P = 4/9 * ∟\n  euclid_finish\n\n",
        "source": "LeanGeo/Exercise/1-1.lean"
    },
    {
        "name": "Example_1_1b",
        "using_lemmas": [
            "intersection_lines",
            "triangle_angleSum",
            "",
            "(△W:P:Z).similar_property",
            "triangle_angleSum",
            "triangle_angleSum",
            "angle_between_transfer",
            "angle_between_transfer"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Example_1_1b :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ W:X:Y = ∟ * 11/9) := by\n",
        "formal_proof": "theorem Example_1_1b :\n  ∀ (W X Y Z : Point) (WX XY YZ ZW WY XZ : Line),\n    (formQuadrilateral W X Y Z WX XY YZ ZW)\n    ∧ (distinctPointsOnLine W Y WY)\n    ∧ (distinctPointsOnLine X Z XZ)\n    ∧ (perpLine XZ WY)\n    ∧ (∠ W:Z:X = ∟/3)\n    ∧ (∠ X:W:Y = ∟ * 4/9)\n    ∧ (∠ W:Y:Z = ∟ * 5/9)\n    → (∠ W:X:Y = ∟ * 11/9) := by\n  euclid_intros\n  euclid_apply intersection_lines XZ WY as P\n  --euclid_assert ∠Z:P:Y = ∟\n  --euclid_assert triangle P Y Z\n  euclid_apply triangle_angleSum P Y Z\n  euclid_assert (△Y:P:Z).similar_test (△X:P:W)\n  euclid_apply  (△Y:P:Z).similar_property (△X:P:W)\n  --euclid_assert ∠X:P:Y = ∠Z:P:W\n  --euclid_assert triangle W P Z\n  --euclid_assert triangle X P Y\n  --euclid_assert |(P─X)| * |(P─Y)| = |(P─Y)| * |(P─X)|\n  --euclid_assert ∠W:P:Z = ∠X:P:Y\n  --euclid_assert (△W:P:Z).similar_test (△X:P:Y)\n  euclid_apply (△W:P:Z).similar_property (△X:P:Y)\n  euclid_apply triangle_angleSum P X Y\n  euclid_apply triangle_angleSum P X W\n  --euclid_apply angle_between_transfer X P Z W\n  --euclid_assert ∠ W:Z:P = ∟ / 3\n  --euclid_apply angle_between_transfer Y P W X\n  --euclid_assert ∠P:X:W = ∟ *5 / 9\n  --euclid_assert ∠P:Y:X = ∟ * 3 / 9\n  --euclid_assert ∠P:X:Y = 2 * 3 / ∟\n  --euclid_assert ∠Y:Z:P = 4/9 * ∟\n  euclid_finish\n",
        "source": "LeanGeo/Exercise/1-1.lean"
    },
    {
        "name": "HL_congruent",
        "using_lemmas": [
            "pythagorean_point",
            "pythagorean_point"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem HL_congruent : ∀ (a b c d e f : Point) ,  rightTriangle a b c ∧ rightTriangle d e f ∧ |(a─b)| = |(d─e)| ∧ |(b─c)| = |(e─f)| → (△a:b:c).congruent_test (△d:e:f) := by\n",
        "formal_proof": "theorem HL_congruent : ∀ (a b c d e f : Point) ,  rightTriangle a b c ∧ rightTriangle d e f ∧ |(a─b)| = |(d─e)| ∧ |(b─c)| = |(e─f)| → (△a:b:c).congruent_test (△d:e:f) := by\n  euclid_intros\n  euclid_apply pythagorean_point a b c\n  euclid_apply pythagorean_point d e f\n  have h1 : |(a─b)| = |(d─e)| := by\n    euclid_finish\n  have h2 : |(b─c)| = |(e─f)| := by\n    euclid_finish\n  have h4 : |(e─f)| * |(e─f)| = |(d─e)| * |(d─e)| + |(d─f)| * |(d─f)| := by\n    euclid_finish\n  have h3 : |(b─c)| * |(b─c)| = |(a─b)| * |(a─b)| + |(a─c)| * |(a─c)| := by\n    euclid_finish\n  have h5 : |(a─c)| = |(d─f)| := by\n    rw [h1, h2] at h3\n    have h6 : |(a─c)| * |(a─c)| = |(d─f)| * |(d─f)| := by linarith\n    have h7 : |(a─c)| > 0 := by euclid_finish\n    have h8 : |(d─f)| > 0 := by euclid_finish\n    nlinarith [h6, h7, h8]\n  euclid_finish\n",
        "source": "LeanGeo/Annotate100/HL.lean"
    },
    {
        "name": "quadrilateral_line_from_side_sameside",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem quadrilateral_line_from_side_sameside : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ distinctPointsOnLine E F EF ∧ between B E C ∧ between A F D → A.sameSide B EF := by\n",
        "formal_proof": "theorem quadrilateral_line_from_side_sameside : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ distinctPointsOnLine E F EF ∧ between B E C ∧ between A F D → A.sameSide B EF := by\n  sorry\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "parallelogram_median_mid_mid_para",
        "using_lemmas": [
            "parallelogram_eqSide",
            "quadrilateral_line_from_side_sameside",
            "parallelogram_tests"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem parallelogram_median_mid_mid_para : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), parallelogram A B C D AB BC CD DA ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n",
        "formal_proof": "theorem parallelogram_median_mid_mid_para : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), parallelogram A B C D AB BC CD DA ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n  euclid_intros\n  euclid_apply parallelogram_eqSide A B C D AB BC CD DA\n  have h0: parallelogram E F D C EF DA CD BC := by\n    have h1: A.sameSide B EF := by\n      euclid_apply quadrilateral_line_from_side_sameside A B C D E F AB BC CD DA EF\n      euclid_finish\n    euclid_assert formQuadrilateral E F D C EF DA CD BC\n    euclid_apply parallelogram_tests E F D C EF DA CD BC\n    euclid_finish\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "between_between_opposingSides",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem between_between_opposingSides : ∀ (A B C: Point) (l : Line), A.onLine l ∧ between B A C ∧ ¬ B.onLine l → B.opposingSides C l := by\n",
        "formal_proof": "theorem between_between_opposingSides : ∀ (A B C: Point) (l : Line), A.onLine l ∧ between B A C ∧ ¬ B.onLine l → B.opposingSides C l := by\n  euclid_intros\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "para_similar_in",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "parallel_eqAlternateAngles",
            "parallel_eqAlternateAngles",
            "similar_AA"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem para_similar_in : ∀ (A B C D E : Point) (AB CD : Line), distinctPointsOnLine A B AB ∧ distinctPointsOnLine C D CD ∧ ¬ AB.intersectsLine CD ∧ between A E C ∧ coll B E D ∧ AB ≠ CD → similarTriangle A B E C D E := by\n",
        "formal_proof": "theorem para_similar_in : ∀ (A B C D E : Point) (AB CD : Line), distinctPointsOnLine A B AB ∧ distinctPointsOnLine C D CD ∧ ¬ AB.intersectsLine CD ∧ between A E C ∧ coll B E D ∧ AB ≠ CD → similarTriangle A B E C D E := by\n  euclid_intros\n  euclid_apply line_from_points B D as BD\n  euclid_apply line_from_points A C as AC\n  euclid_assert B.opposingSides D AC\n  have h1: ∠B:A:E = ∠D:C:E := by\n    have h2: ∠B:A:C = ∠A:C:D := by\n      euclid_apply parallel_eqAlternateAngles AB CD AC A C B D\n      euclid_finish\n    euclid_finish\n  have h3: ∠A:B:E = ∠C:D:E := by\n    have h4: ∠A:B:D = ∠C:D:B := by\n      euclid_apply parallel_eqAlternateAngles AB CD BD B D A C\n      euclid_finish\n    euclid_finish\n  euclid_apply similar_AA A B E C D E\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "para_similar_out",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem para_similar_out: ∀ (A B C D E : Point) (AB CD : Line), distinctPointsOnLine A B AB ∧ distinctPointsOnLine C D CD ∧ ¬ AB.intersectsLine CD ∧ between E A C ∧ coll B E D ∧ AB ≠ CD → (△A:B:E).similar_test (△C:D:E) := by\n",
        "formal_proof": "theorem para_similar_out: ∀ (A B C D E : Point) (AB CD : Line), distinctPointsOnLine A B AB ∧ distinctPointsOnLine C D CD ∧ ¬ AB.intersectsLine CD ∧ between E A C ∧ coll B E D ∧ AB ≠ CD → (△A:B:E).similar_test (△C:D:E) := by\n  sorry\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "trapezoid_median_mid_mid_para1",
        "using_lemmas": [
            "euclid_apply",
            "euclid_apply"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem trapezoid_median_mid_mid_para1 : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ (¬ AB.intersectsLine CD) ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n",
        "formal_proof": "theorem trapezoid_median_mid_mid_para1 : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ (¬ AB.intersectsLine CD) ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n  euclid_intros\n  by_cases h: BC.intersectsLine DA\n  · euclid_apply intersection_lines BC DA as G\n    by_cases between G B E\n    · sorry\n    · sorry\n  · euclid_apply parallelogram_median_mid_mid_para A B C D E F AB BC CD DA EF\n    euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "trapezoid_median_mid_mid_para",
        "using_lemmas": [
            "line_from_points",
            "intersection_lines",
            "para_similar_in",
            "",
            "congruent_ASA",
            "triangle_median_line_parallel"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem trapezoid_median_mid_mid_para : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ (¬ AB.intersectsLine CD) ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n",
        "formal_proof": "theorem trapezoid_median_mid_mid_para : ∀ (A B C D E F: Point) (AB BC CD DA EF: Line), formQuadrilateral A B C D AB BC CD DA ∧ (¬ AB.intersectsLine CD) ∧ distinctPointsOnLine E F EF ∧ midpoint B E C ∧ midpoint A F D →  (¬ EF.intersectsLine CD) := by\n  euclid_intros\n  euclid_apply line_from_points A E as AE\n  euclid_apply intersection_lines CD AE as G\n  have h1: |(A─E)| = |(E─G)| := by\n    euclid_apply para_similar_in B A C G E AB CD\n    euclid_apply  similar_AA B A E C G E\n    euclid_assert |(B─E)| = |(C─E)|\n    euclid_apply congruent_ASA B E A C E G\n    euclid_finish\n  have h2: ¬ EF.intersectsLine CD := by\n    euclid_apply triangle_median_line_parallel A D G F E DA CD AE\n    euclid_finish\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "acute_triangle_foot_between",
        "using_lemmas": [
            "triangle_exteriorAngle",
            "triangle_exteriorAngle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem acute_triangle_foot_between : ∀(A B C D: Point) (BC: Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C < ∟ ∧ ∠ A:C:B < ∟ → between B D C := by\n",
        "formal_proof": "theorem acute_triangle_foot_between : ∀(A B C D: Point) (BC: Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C < ∟ ∧ ∠ A:C:B < ∟ → between B D C := by\n  euclid_intros\n  have h2: ¬(between D B C):= by\n    by_contra\n    euclid_apply triangle_exteriorAngle D B A C\n    euclid_finish\n  have h3: ¬(between B C D):= by\n    by_contra\n    euclid_apply triangle_exteriorAngle D C A B\n    euclid_finish\n  euclid_finish\n\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "acute_triangle_foot_between2",
        "using_lemmas": [
            "triangle_exteriorAngle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem acute_triangle_foot_between2 : ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C < ∟ ∧ ∠ A:C:B < ∟ → between B D C := by\n",
        "formal_proof": "theorem acute_triangle_foot_between2 : ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C < ∟ ∧ ∠ A:C:B < ∟ → between B D C := by\n  euclid_intros\n  euclid_apply triangle_exteriorAngle\n  euclid_finish\n\n\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "obtuse_triangle_foot_between",
        "using_lemmas": [
            "angle_between_transfer",
            "triangle_angleSum",
            "angle_between_transfer",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem obtuse_triangle_foot_between: ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C > ∟ → between D B C := by\n",
        "formal_proof": "theorem obtuse_triangle_foot_between: ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C > ∟ → between D B C := by\n  euclid_intros\n  have h2: ¬(between B C D):= by\n    by_contra\n    euclid_apply angle_between_transfer B C D A\n    euclid_apply triangle_angleSum A B D\n    euclid_finish\n  have h3: ¬(between B D C):= by\n    by_contra\n    euclid_apply angle_between_transfer B D C A\n    euclid_apply triangle_angleSum A B D\n    euclid_finish\n  have h4: D ≠ C := by\n    euclid_apply triangle_angleSum A B D\n    euclid_finish\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "obtuse_triangle_foot_between2",
        "using_lemmas": [
            "angle_between_transfer",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem obtuse_triangle_foot_between2: ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C > ∟ → between D B C := by\n",
        "formal_proof": "theorem obtuse_triangle_foot_between2: ∀(A B C D: Point) (BC : Line), distinctPointsOnLine B C BC ∧ foot A D BC ∧ ∠A:B:C > ∟ → between D B C := by\n  euclid_intros\n  euclid_apply angle_between_transfer\n  euclid_apply triangle_angleSum\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "perp_foot",
        "using_lemmas": [
            "angle_between_transfer"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem perp_foot: ∀ (A B C: Point) (l : Line), ¬ A.onLine l ∧ distinctPointsOnLine B C l ∧ ∠A:B:C = ∟ → foot A B l:= by\n",
        "formal_proof": "theorem perp_foot: ∀ (A B C: Point) (l : Line), ¬ A.onLine l ∧ distinctPointsOnLine B C l ∧ ∠A:B:C = ∟ → foot A B l:= by\n  euclid_intros\n  euclid_apply angle_between_transfer\n  euclid_finish\n\n/--3. In an acute-angled triangle $ABC$, two altitudes $AD$ and $CE$ are drawn. Perpendiculars $AM$ and $CN$ are dropped from points $A$ and $C$ to the line $DE$. Prove that $ME = DN$.-/\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "Numina_Geometry_1001",
        "using_lemmas": [
            "exists_midpoint",
            "circle_from_points",
            "acute_triangle_foot_between",
            "acute_triangle_foot_between",
            "rightAngle_diameter_onCircle",
            "rightAngle_diameter_onCircle",
            "line_from_points",
            "line_from_points",
            "obtuse_triangle_foot_between",
            "obtuse_triangle_foot_between",
            "supplementConsecutiveAngles_parallel",
            "exists_midpoint",
            "line_from_points",
            "trapezoid_median_mid_mid_para",
            "parallel_supplementConsecutiveAngle",
            "perp_foot",
            "chord_foot_midpoint"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Numina_Geometry_1001 :\n  ∀ (A B C D E M N : Point) (AB BC CA DE: Line),\n    formAcuteTriangle A B C AB BC CA ∧\n    foot A D BC  ∧\n    foot C E AB ∧\n    distinctPointsOnLine D E DE ∧\n    foot A M DE ∧\n    foot C N DE →\n    |(M─E)| = |(D─N)| := by\n",
        "formal_proof": "theorem Numina_Geometry_1001 :\n  ∀ (A B C D E M N : Point) (AB BC CA DE: Line),\n    formAcuteTriangle A B C AB BC CA ∧\n    foot A D BC  ∧\n    foot C E AB ∧\n    distinctPointsOnLine D E DE ∧\n    foot A M DE ∧\n    foot C N DE →\n    |(M─E)| = |(D─N)| := by\n  euclid_intros\n  euclid_apply exists_midpoint A C as O\n  euclid_apply circle_from_points O A as Ω\n  have h1: between A E B := by\n    euclid_apply acute_triangle_foot_between C A B E AB\n    euclid_finish\n  have h2: between B D C := by\n    euclid_apply acute_triangle_foot_between A B C D BC\n    euclid_finish\n  have h3: E.onCircle Ω := by\n    euclid_apply rightAngle_diameter_onCircle A C E O Ω\n    euclid_finish\n  have h4: D.onCircle Ω := by\n    euclid_apply rightAngle_diameter_onCircle A C D O Ω\n    euclid_finish\n  euclid_apply line_from_points A M as AM\n  euclid_apply line_from_points C N as CN\n  have h5: between M E D := by\n    euclid_apply obtuse_triangle_foot_between A E D M DE\n    euclid_finish\n  have h7: between N D E := by\n    euclid_apply obtuse_triangle_foot_between C D E N DE\n    euclid_finish\n  have h9: ¬(AM.intersectsLine CN):= by\n    euclid_apply supplementConsecutiveAngles_parallel AM CN DE M N A C\n    euclid_finish\n  euclid_apply exists_midpoint M N as P\n  euclid_apply line_from_points P O as PO\n  have h10: ¬(PO.intersectsLine CN) := by\n    euclid_apply trapezoid_median_mid_mid_para A M N C P O AM DE CN CA PO\n    euclid_finish\n  have h11: foot O P DE := by\n    have h12: ∠O:P:N = ∟ := by\n      euclid_apply parallel_supplementConsecutiveAngle PO CN DE P N O C\n      euclid_finish\n    euclid_apply perp_foot O P N DE\n    euclid_finish\n  have h13: midpoint E P D := by\n    euclid_apply chord_foot_midpoint O D E P Ω DE\n    euclid_finish\n  euclid_finish\n",
        "source": "LeanGeo/Annotate100/7.lean"
    },
    {
        "name": "Numina_Geometry_19",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem Numina_Geometry_19 :\n  ∀ (A B C D E : Point) (AB BC CA p t : Line) (O : Circle),\n    formTriangle A B C AB BC CA ∧\n    circumCircle O A B C ∧\n    tangentAtPoint t O C ∧\n    p ≠ t ∧\n    (¬ p.intersectsLine t) ∧\n    D.onLine p ∧\n    D.onLine BC ∧\n    E.onLine p ∧\n    E.onLine CA →\n    cyclic A B D E := by\n",
        "formal_proof": "theorem Numina_Geometry_19 :\n  ∀ (A B C D E : Point) (AB BC CA p t : Line) (O : Circle),\n    formTriangle A B C AB BC CA ∧\n    circumCircle O A B C ∧\n    tangentAtPoint t O C ∧\n    p ≠ t ∧\n    (¬ p.intersectsLine t) ∧\n    D.onLine p ∧\n    D.onLine BC ∧\n    E.onLine p ∧\n    E.onLine CA →\n    cyclic A B D E := by\n    sorry\n",
        "source": "LeanGeo/Annotate100/3.lean"
    },
    {
        "name": "triangle_area",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem triangle_area :∀ (a b c d: Point), (coll a b d) ∧ (triangle a b c) ∧ ((∠c:d:a = ∟) ∨ (∠c:d:b = ∟)) → (△a:b:c).area = |(c─d)| * |(a─b)| := by\n",
        "formal_proof": "theorem triangle_area :∀ (a b c d: Point), (coll a b d) ∧ (triangle a b c) ∧ ((∠c:d:a = ∟) ∨ (∠c:d:b = ∟)) → (△a:b:c).area = |(c─d)| * |(a─b)| := by\n  sorry\n\n/--5. If two altitudes of a triangle are equal, then the triangle is isosceles.-/\n",
        "source": "LeanGeo/Annotate100/1.lean"
    },
    {
        "name": "Numina_Geometry_557",
        "using_lemmas": [
            "triangle_area",
            "triangle_area"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Numina_Geometry_557 :\n  ∀ (a b c d e : Point),\n    (triangle a b c) ∧\n    coll b c d ∧\n    coll a c e ∧\n    ∠ a:e:b = ∟ ∧\n    ∠ a:d:b = ∟ ∧ e ≠ a ∧ d ≠ b ∧\n    (|(a─d)| = |(b─e)|)\n    → isoTriangle c a b := by\n",
        "formal_proof": "theorem Numina_Geometry_557 :\n  ∀ (a b c d e : Point),\n    (triangle a b c) ∧\n    coll b c d ∧\n    coll a c e ∧\n    ∠ a:e:b = ∟ ∧\n    ∠ a:d:b = ∟ ∧ e ≠ a ∧ d ≠ b ∧\n    (|(a─d)| = |(b─e)|)\n    → isoTriangle c a b := by\n    euclid_intros\n    euclid_assert triangle c a b\n    euclid_assert ∠ b:e:a = ∠ a:e:b\n    euclid_apply triangle_area c a b e\n    euclid_apply triangle_area c b a d\n    --euclid_assert |(b─e)| * |(c─a)| = |(a─d)| * |(c─b)|\n    euclid_finish\n",
        "source": "LeanGeo/Annotate100/1.lean"
    },
    {
        "name": "inside_power_sameline",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inside_power_sameline: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ between A P B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(P─O)| * |(P─O)| = |(O─A)| * |(O─A)| := by\n",
        "formal_proof": "theorem inside_power_sameline: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ between A P B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(P─O)| * |(P─O)| = |(O─A)| * |(O─A)| := by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/5.lean"
    },
    {
        "name": "outside_power_sameline",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem outside_power_sameline: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧  between P A B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(O─A)| * |(O─A)|= |(P─O)| * |(P─O)|  := by\n",
        "formal_proof": "theorem outside_power_sameline: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧  between P A B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(O─A)| * |(O─A)|= |(P─O)| * |(P─O)|  := by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/5.lean"
    },
    {
        "name": "inside_power",
        "using_lemmas": [
            "euclid_apply",
            "euclid_apply",
            "intersections_circle_line",
            "cyclic_power"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inside_power: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ between A P B → |(P─A)| * |(P─B)| + |(P─O)| * |(P─O)|= |(O─A)| * |(O─A)|  := by\n",
        "formal_proof": "theorem inside_power: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ between A P B → |(P─A)| * |(P─B)| + |(P─O)| * |(P─O)|= |(O─A)| * |(O─A)|  := by\n  euclid_intros\n  by_cases h: coll A O B\n  · euclid_apply inside_power_sameline P O A B C\n    euclid_finish\n  · euclid_apply line_from_points O P as l\n    euclid_apply intersections_circle_line C l as (S,T)\n    have h1 : |(P─A)| * |(P─B)| = |(P─S)| * |(P─T)| := by\n      euclid_apply cyclic_power S T A B P\n      euclid_finish\n    rw[h1]\n    euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/5.lean"
    },
    {
        "name": "outside_power",
        "using_lemmas": [
            "euclid_apply",
            "euclid_apply",
            "intersections_circle_line",
            "cyclic_power"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem outside_power: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧  between P A B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(O─A)| * |(O─A)|= |(P─O)| * |(P─O)|  := by\n",
        "formal_proof": "theorem outside_power: ∀ (P O A B: Point) (C: Circle),O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧  between P A B ∧ coll A O B→ |(P─A)| * |(P─B)| + |(O─A)| * |(O─A)|= |(P─O)| * |(P─O)|  := by\n  euclid_intros\n  by_cases h: coll A O B\n  · euclid_apply outside_power_sameline P O A B C\n    euclid_finish\n  · euclid_apply line_from_points O P as l\n    euclid_apply intersections_circle_line C l as (S,T)\n    have h1 : |(P─A)| * |(P─B)| = |(P─S)| * |(P─T)| := by\n      euclid_apply cyclic_power S T A B P\n      euclid_finish\n    rw[h1]\n    euclid_finish\n\n/--4. A square $O M K N$ is inscribed in a circle such that vertex $O$ coincides with the center of the circle, and vertex $K$ lies on the circle. Chord $A B$ of the circle passes through vertex $M$, and chord $\\mathrm{CD}$ passes through vertex $\\mathrm{N}$. Prove that $A M \\cdot M B=C N \\cdot N D$.-/\n",
        "source": "LeanGeo/Annotate100/5.lean"
    },
    {
        "name": "Numina_Geometry_925",
        "using_lemmas": [
            "pythagorean_point",
            "pythagorean_point",
            "inside_power",
            "inside_power"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Numina_Geometry_925 :\n  ∀ (O M K N A B C D : Point) (Ω : Circle)\n    (OM MK KN NO AB CD : Line),\n    square O M K N OM MK KN NO ∧\n    O.isCentre Ω ∧\n    K.onCircle Ω ∧\n    threePointsOnLine A M B AB ∧\n    threePointsOnLine C N D CD ∧\n    A.onCircle Ω ∧\n    B.onCircle Ω ∧\n    C.onCircle Ω ∧\n    D.onCircle Ω →\n    |(A─M)| * |(M─B)| = |(C─N)| * |(N─D)| := by\n",
        "formal_proof": "theorem Numina_Geometry_925 :\n  ∀ (O M K N A B C D : Point) (Ω : Circle)\n    (OM MK KN NO AB CD : Line),\n    square O M K N OM MK KN NO ∧\n    O.isCentre Ω ∧\n    K.onCircle Ω ∧\n    threePointsOnLine A M B AB ∧\n    threePointsOnLine C N D CD ∧\n    A.onCircle Ω ∧\n    B.onCircle Ω ∧\n    C.onCircle Ω ∧\n    D.onCircle Ω →\n    |(A─M)| * |(M─B)| = |(C─N)| * |(N─D)| := by\n    euclid_intros\n    have h1: M.insideCircle Ω := by\n      have h2: |(M─O)| < |(K─O)| := by\n        euclid_apply pythagorean_point M O K\n        euclid_finish\n      euclid_finish\n    have h3: N.insideCircle Ω := by\n      have h4: |(N─O)| < |(K─O)| := by\n        euclid_apply pythagorean_point N O K\n        euclid_finish\n      euclid_finish\n    euclid_apply inside_power M O A B Ω\n    euclid_apply inside_power N O C D Ω\n    have h3: |(M─O)| = |(N─O)| := by\n      euclid_finish\n    euclid_finish\n--11s\n",
        "source": "LeanGeo/Annotate100/5.lean"
    },
    {
        "name": "triangle_median_line_half'",
        "using_lemmas": [
            "line_from_points",
            "(△"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem triangle_median_line_half' : ∀ (a b c d e : Point), triangle a b c ∧ midpoint a d b ∧ midpoint a e c → |(b─c)| = |(d─e)| * 2:= by\n",
        "formal_proof": "theorem triangle_median_line_half' : ∀ (a b c d e : Point), triangle a b c ∧ midpoint a d b ∧ midpoint a e c → |(b─c)| = |(d─e)| * 2:= by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_assert |(a─b)| * |(a─e)| = |(a─c)| * |(a─d)|\n  euclid_assert (△ a:b:c).similar_test ((△ a:d:e))\n  euclid_apply (△ a:b:c).similar_property ((△ a:d:e))\n  euclid_finish\n",
        "source": "LeanGeo/Annotate100/6.lean"
    },
    {
        "name": "Numina_Geometry_932",
        "using_lemmas": [
            "triangle_median_line_half",
            "triangle_median_line_half",
            "(△"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Numina_Geometry_932 :\n  ∀ (A B C D K L M N S : Point) (AB BC CD DA : Line),\n    formQuadrilateral A B C D AB BC CD DA ∧\n    midpoint A K B ∧\n    midpoint B L C ∧\n    midpoint C M D ∧\n    midpoint D N A ∧\n    triangle K L S ∧ triangle N M S ∧\n    |(K─S)| = |(L─S)| ∧\n    |(N─S)| = |(M─S)|\n    → ∠ K:S:N = ∠ M:S:L := by\n",
        "formal_proof": "theorem Numina_Geometry_932 :\n  ∀ (A B C D K L M N S : Point) (AB BC CD DA : Line),\n    formQuadrilateral A B C D AB BC CD DA ∧\n    midpoint A K B ∧\n    midpoint B L C ∧\n    midpoint C M D ∧\n    midpoint D N A ∧\n    triangle K L S ∧ triangle N M S ∧\n    |(K─S)| = |(L─S)| ∧\n    |(N─S)| = |(M─S)|\n    → ∠ K:S:N = ∠ M:S:L := by\n    euclid_intros\n    have h1: |(K─N)| = |(M─L)| := by\n      have h2: |(K─N)| * 2 = |(B─D)|:= by\n        euclid_apply triangle_median_line_half A B D K N\n        euclid_finish\n      have h3: |(L─M)| * 2 = |(B─D)|:= by\n        euclid_apply triangle_median_line_half C B D L M\n        euclid_finish\n      euclid_finish\n    euclid_apply (△ K:N:S).congruent_property ((△ L:M:S))\n    euclid_finish\n",
        "source": "LeanGeo/Annotate100/6.lean"
    },
    {
        "name": "between_angleSum",
        "using_lemmas": [
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem between_angleSum : ∀(a b c d: Point), between b c d ∧ (¬ coll a b c) → ∠d:a:c + ∠c:a:b = ∠d:a:b:= by\n",
        "formal_proof": "theorem between_angleSum : ∀(a b c d: Point), between b c d ∧ (¬ coll a b c) → ∠d:a:c + ∠c:a:b = ∠d:a:b:= by\n  euclid_intros\n  euclid_apply line_from_points\n  euclid_finish\n\n",
        "source": "LeanGeo/Annotate100/4.lean"
    },
    {
        "name": "angle_bisector_between",
        "using_lemmas": [
            "triangle_anglePositive",
            "angle_coincide_zero",
            "angle_coincide_zero",
            "between_angleSum",
            "between_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem angle_bisector_between: ∀ (a b c d: Point), (triangle a b c) ∧ (coll b d c) ∧ (∠d:a:c = ∠d:a:b) → between b d c := by\n",
        "formal_proof": "theorem angle_bisector_between: ∀ (a b c d: Point), (triangle a b c) ∧ (coll b d c) ∧ (∠d:a:c = ∠d:a:b) → between b d c := by\n  euclid_intros\n  euclid_assert d ≠ a\n  euclid_apply triangle_anglePositive a b c\n  have :d ≠ b := by\n    by_contra\n    euclid_apply angle_coincide_zero d a\n    euclid_assert ∠b:a:c = 0\n    euclid_finish\n  have : d ≠ c := by\n    by_contra\n    euclid_apply angle_coincide_zero d a\n    euclid_finish\n  have : ¬ (between d c b) := by\n    by_contra\n    euclid_apply between_angleSum a b c d\n    euclid_finish\n  have : ¬ (between c b d) := by\n    by_contra\n    euclid_apply between_angleSum a c b d\n    euclid_finish\n  euclid_finish\n\n\n\n",
        "source": "LeanGeo/Annotate100/4.lean"
    },
    {
        "name": "Numina_Geometry_617",
        "using_lemmas": [
            "line_from_points",
            "parallel_eqAlternateAngles",
            "angle_bisector_between",
            "angle_bisector_between",
            "triangle_exteriorAngle",
            "between_angleSum",
            "triangle_exteriorAngle",
            "angle_between_transfer",
            "line_from_points",
            "parallel_eqAlternateExteriorAngle",
            "between_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Numina_Geometry_617 :\n  ∀ (a b c d e f : Point) (BD EF : Line),\n    triangle a b c ∧\n    coll a d c ∧\n    coll b e c ∧\n    coll d f c ∧\n    distinctPointsOnLine b d BD ∧\n    distinctPointsOnLine e f EF ∧\n    ∠ a:b:d = ∠ d:b:c ∧\n    ∠ b:d:e = ∠ e:d:c ∧\n    ∠ d:e:f = ∠ f:e:c ∧\n    ¬ (BD.intersectsLine EF)\n    → ∠ a:b:c = ∠ b:a:c + ∠ b:a:c := by\n",
        "formal_proof": "theorem Numina_Geometry_617 :\n  ∀ (a b c d e f : Point) (BD EF : Line),\n    triangle a b c ∧\n    coll a d c ∧\n    coll b e c ∧\n    coll d f c ∧\n    distinctPointsOnLine b d BD ∧\n    distinctPointsOnLine e f EF ∧\n    ∠ a:b:d = ∠ d:b:c ∧\n    ∠ b:d:e = ∠ e:d:c ∧\n    ∠ d:e:f = ∠ f:e:c ∧\n    ¬ (BD.intersectsLine EF)\n    → ∠ a:b:c = ∠ b:a:c + ∠ b:a:c := by\n    euclid_intros\n    euclid_apply line_from_points d e as DE\n    euclid_assert b.opposingSides f DE\n    euclid_apply parallel_eqAlternateAngles BD EF DE d e b f\n    have h1 : between b e c:= by\n      euclid_apply angle_bisector_between d b c e\n      euclid_finish\n    have h2 : between a d c := by\n      euclid_apply angle_bisector_between b a c d\n      euclid_finish\n    euclid_apply triangle_exteriorAngle b e d c\n    have h3 : ∠a:b:c = ∠a:b:d + ∠c:b:d := by\n      euclid_apply between_angleSum b a d c\n      euclid_finish\n    have h4 : ∠b:d:c = ∠d:b:a + ∠b:a:d := by\n      euclid_apply triangle_exteriorAngle a d b c\n      euclid_finish\n    have h5 : ∠b:a:c = ∠b:a:d := by\n      euclid_apply angle_between_transfer a d c b\n      euclid_finish\n    rw [h3, h5]\n    have h6 : ∠c:b:d = ∠e:d:b := by\n      euclid_apply line_from_points b c as BC\n      have h7: ∠c:b:d = ∠c:e:f := by\n        euclid_apply parallel_eqAlternateExteriorAngle f e d b c EF BD BC\n        euclid_finish\n      euclid_finish\n    have h8: 2 * ∠e:d:b = ∠b:d:c := by\n      have h11: ∠b:d:c = ∠e:d:b + ∠e:d:c := by\n        euclid_apply between_angleSum d b e c\n        euclid_finish\n      rw [h11]\n      euclid_finish\n    have h9: ∠c:b:d = ∠d:a:b := by\n      have h10: ∠c:b:d = (∠c:b:d + ∠d:a:b) / 2 := by\n        calc\n          _ = ∠e:d:b := by rw[h6]\n          _ = ∠ b:d:c / 2 := by\n            rw[← h8]\n            linarith\n          _ = (∠d:b:a + ∠b:a:d)/2 := by rw [h4]\n          _ = _ := by\n            euclid_finish\n      linarith\n    rw[h9]\n    euclid_finish\n--Compile time: 9s\n",
        "source": "LeanGeo/Annotate100/4.lean"
    },
    {
        "name": "opposingsides_inside_triangle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n",
        "formal_proof": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n  euclid_intros\n  sorry\n\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "angleBisector_opposingsides",
        "using_lemmas": [
            "line_from_points",
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n",
        "formal_proof": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n  euclid_intros\n  by_contra\n  euclid_apply line_from_points A C as AC\n  euclid_apply line_from_points A B as AB\n  euclid_finish\n\n\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "incenter_inside",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "opposingsides_inside_triangle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n",
        "formal_proof": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n  euclid_intros\n  euclid_apply line_from_points A I as AI\n  euclid_apply line_from_points B I as BI\n  euclid_apply line_from_points C I as CI\n  euclid_apply angleBisector_opposingsides A B C I AI\n  euclid_apply angleBisector_opposingsides C A B I CI\n  euclid_apply angleBisector_opposingsides B C A I BI\n  euclid_apply opposingsides_inside_triangle A B C I AB BC CA AI BI CI\n  euclid_finish\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "exists_inCentre",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exists_inCentre : ∀ (A B C: Point), triangle A B C → ∃ (I : Point), inCentre I A B C := by\n",
        "formal_proof": "theorem exists_inCentre : ∀ (A B C: Point), triangle A B C → ∃ (I : Point), inCentre I A B C := by\n  sorry\n\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "exCentre_inCentre_coll",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem exCentre_inCentre_coll : ∀ (A B C I J: Point), triangle A B C ∧ inCentre I A B C ∧ exCentre J A B C → between A I J := by\n",
        "formal_proof": "theorem exCentre_inCentre_coll : ∀ (A B C I J: Point), triangle A B C ∧ inCentre I A B C ∧ exCentre J A B C → between A I J := by\n  sorry\n\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "circumCentre_isCentre_circumCircle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem circumCentre_isCentre_circumCircle : ∀ (A B C O : Point) (Ω : Circle), triangle A B C ∧ circumCircle Ω A B C ∧ circumCentre O A B C → O.isCentre Ω := by\n",
        "formal_proof": "theorem circumCentre_isCentre_circumCircle : ∀ (A B C O : Point) (Ω : Circle), triangle A B C ∧ circumCircle Ω A B C ∧ circumCentre O A B C → O.isCentre Ω := by\n  euclid_intros\n  sorry\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "Numina_Geometry_1293",
        "using_lemmas": [
            "exists_inCentre",
            "line_from_points",
            "line_from_points",
            "incenter_inside",
            "exCentre_inCentre_coll",
            "line_from_points",
            "line_from_points",
            "cyclic_test",
            "circumCentre_isCentre_circumCircle",
            "rightAngle_diameter"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem Numina_Geometry_1293 :\n  ∀ (A B C D O : Point) (AB BC CA : Line),\n    formAcuteTriangle A B C AB BC CA ∧\n    circumCentre O A B C ∧\n    (∠A:B:C + ∠A:B:D = ∟ + ∟) ∧\n    (∠A:C:B + ∠A:C:D = ∟ + ∟) →\n    between A O D := by\n",
        "formal_proof": "theorem Numina_Geometry_1293 :\n  ∀ (A B C D O : Point) (AB BC CA : Line),\n    formAcuteTriangle A B C AB BC CA ∧\n    circumCentre O A B C ∧\n    (∠A:B:C + ∠A:B:D = ∟ + ∟) ∧\n    (∠A:C:B + ∠A:C:D = ∟ + ∟) →\n    between A O D := by\n    euclid_intros\n    euclid_assert triangle D B C\n    euclid_apply exists_inCentre D B C as I\n    euclid_apply line_from_points B D as BD\n    euclid_apply line_from_points C D as CD\n    --euclid_assert formTriangle B C D BC CD BD\n    euclid_apply incenter_inside B C D I BC CD BD\n    euclid_assert ∠I:B:C + ∠I:B:D = ∠ C:B:D\n    have h1: ∠A:B:D = ∠A:B:C + ∠C:B:D := by\n      sorry\n    have h2: ∠A:C:D = ∠A:C:B + ∠B:C:D := by\n      sorry\n    euclid_assert ∠I:B:A = ∟\n    euclid_assert ∠I:C:A = ∟\n    euclid_apply exCentre_inCentre_coll D B C I A\n    euclid_apply line_from_points B I as BI\n    euclid_apply line_from_points C I as CI\n    euclid_assert formQuadrilateral A C I B CA CI BI AB\n    euclid_apply cyclic_test A C I B CA CI BI AB as Ω\n    euclid_apply circumCentre_isCentre_circumCircle A B C O Ω\n    euclid_apply rightAngle_diameter B I A O Ω\n    euclid_finish\n",
        "source": "LeanGeo/Annotate100/2.lean"
    },
    {
        "name": "circumcenter_acute_inside",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem circumcenter_acute_inside : ∀ (A B C O: Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) →\n  insideTriangle O A B C AB BC CA := by\n",
        "formal_proof": "theorem circumcenter_acute_inside : ∀ (A B C O: Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) →\n  insideTriangle O A B C AB BC CA := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem/1-7.lean"
    },
    {
        "name": "orthocenter_acute_inside",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem orthocenter_acute_inside : ∀ (A B C H: Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (orthoCentre H A B C) →\n  insideTriangle H A B C AB BC CA := by\n",
        "formal_proof": "theorem orthocenter_acute_inside : ∀ (A B C H: Point) (AB BC CA : Line),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (orthoCentre H A B C) →\n  insideTriangle H A B C AB BC CA := by\n  sorry\n",
        "source": "LeanGeo/Theorem/1-7.lean"
    },
    {
        "name": "circumcircle_circumcenter",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem circumcircle_circumcenter: ∀ (A B C O: Point) (Ω: Circle),\n  (circumCentre O A B C) ∧\n  (circumCircle Ω A B C) →\n  O.isCentre Ω := by\n",
        "formal_proof": "theorem circumcircle_circumcenter: ∀ (A B C O: Point) (Ω: Circle),\n  (circumCentre O A B C) ∧\n  (circumCircle Ω A B C) →\n  O.isCentre Ω := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem/1-7.lean"
    },
    {
        "name": "circumcenter_orthocenter_eqAngle",
        "using_lemmas": [
            "circumcenter_acute_inside",
            "orthocenter_acute_inside",
            "threePoints_existCircle",
            "circumcircle_circumcenter",
            "circumcenter_inscribed_angle_complementary",
            "line_from_points",
            "intersection_lines",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem circumcenter_orthocenter_eqAngle: ∀ (A B C O H : Point) (AB BC CA : Line)(Ω: Circle),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) ∧\n  (circumCircle Ω A B C) ∧\n  (orthoCentre H A B C) →\n  ∠B:A:H = ∠C:A:O := by\n",
        "formal_proof": "theorem circumcenter_orthocenter_eqAngle: ∀ (A B C O H : Point) (AB BC CA : Line)(Ω: Circle),\n  (formAcuteTriangle A B C AB BC CA) ∧\n  (circumCentre O A B C) ∧\n  (circumCircle Ω A B C) ∧\n  (orthoCentre H A B C) →\n  ∠B:A:H = ∠C:A:O := by\n  euclid_intros\n  euclid_apply circumcenter_acute_inside A B C O AB BC CA\n  euclid_apply orthocenter_acute_inside A B C H AB BC CA\n  euclid_apply threePoints_existCircle A B C as Ω\n  euclid_apply circumcircle_circumcenter A B C O Ω\n  euclid_apply circumcenter_inscribed_angle_complementary C A B O CA AB BC Ω\n  euclid_apply line_from_points A H as AH\n  euclid_apply intersection_lines AH BC as D\n  euclid_assert ∠B:D:A = ∟\n  euclid_apply triangle_angleSum B D A\n  euclid_assert ∠D:B:A = ∠C:B:A\n  euclid_finish\n",
        "source": "LeanGeo/Theorem/1-7.lean"
    },
    {
        "name": "inside_triangle_opposingsides",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inside_triangle_opposingsides :  ∀ (A B C I : Point) (AB BC CA BI : Line), (formTriangle A B C AB BC CA) ∧ (insideTriangle I A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) → A.opposingSides C BI := by\n",
        "formal_proof": "theorem inside_triangle_opposingsides :  ∀ (A B C I : Point) (AB BC CA BI : Line), (formTriangle A B C AB BC CA) ∧ (insideTriangle I A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) → A.opposingSides C BI := by\n  euclid_intros\n  euclid_finish\n\n\n",
        "source": "LeanGeo/Theorem/1-4.lean"
    },
    {
        "name": "opposingsides_inside_triangle",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n",
        "formal_proof": "theorem opposingsides_inside_triangle :  ∀ (A B C I : Point) (AB BC CA AI BI CI : Line), (formTriangle A B C AB BC CA) ∧ (distinctPointsOnLine B I BI) ∧ (distinctPointsOnLine C I CI) ∧ A.opposingSides C BI ∧ B.opposingSides C AI → insideTriangle I A B C AB BC CA:= by\n  euclid_intros\n  sorry\n\n",
        "source": "LeanGeo/Theorem/1-4.lean"
    },
    {
        "name": "angleBisector_opposingsides",
        "using_lemmas": [
            "line_from_points",
            "line_from_points"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n",
        "formal_proof": "theorem angleBisector_opposingsides : ∀ (A B C I : Point) (AI : Line), (distinctPointsOnLine A I AI)∧ triangle A B C ∧ ∠ I:A:B = ∠ I:A:C →  B.opposingSides C AI := by\n  euclid_intros\n  by_contra\n  euclid_apply line_from_points A C as AC\n  euclid_apply line_from_points A B as AB\n  euclid_finish\n\n\n",
        "source": "LeanGeo/Theorem/1-4.lean"
    },
    {
        "name": "incenter_inside",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "angleBisector_opposingsides",
            "opposingsides_inside_triangle"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n",
        "formal_proof": "theorem incenter_inside : ∀ (A B C I : Point) (AB BC CA : Line), (formTriangle A B C AB BC CA) ∧ (inCentre I A B C) → insideTriangle I A B C AB BC CA := by\n  euclid_intros\n  euclid_apply line_from_points A I as AI\n  euclid_apply line_from_points B I as BI\n  euclid_apply line_from_points C I as CI\n  euclid_apply angleBisector_opposingsides A B C I AI\n  euclid_apply angleBisector_opposingsides C A B I CI\n  euclid_apply angleBisector_opposingsides B C A I BI\n  euclid_apply opposingsides_inside_triangle A B C I AB BC CA AI BI CI\n  euclid_finish\n\n--Example 1.4. If I is the incenter of ΔA B C then ∠B I C = 90° + ½A.\n--原则：让题面叙述变得简单？\n",
        "source": "LeanGeo/Theorem/1-4.lean"
    },
    {
        "name": "incenter_angle",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "incenter_inside",
            "self_fullAngle",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem incenter_angle : ∀ (A B C I : Point), (triangle A B C) ∧ (inCentre I A B C) → ∠B:I:C = ∟ + ∠B:A:C / 2 := by\n",
        "formal_proof": "theorem incenter_angle : ∀ (A B C I : Point), (triangle A B C) ∧ (inCentre I A B C) → ∠B:I:C = ∟ + ∠B:A:C / 2 := by\n  euclid_intros\n  euclid_apply line_from_points A B as AB\n  euclid_apply line_from_points A C as CA\n  euclid_apply line_from_points B C as BC\n  --euclid_assert formTriangle A B C AB BC CA\n  euclid_apply incenter_inside A B C I AB BC CA\n  --euclid_apply self_fullAngle A B C I AB BC CA\n  euclid_apply triangle_angleSum I B C\n  euclid_apply triangle_angleSum A B C\n  --euclid_assert ∠A:B:C = 2 * ∠I:B:C\n  --euclid_assert ∠A:C:B = 2 * ∠I:C:B\n  euclid_finish\n",
        "source": "LeanGeo/Theorem/1-4.lean"
    },
    {
        "name": "self_fullAngle",
        "using_lemmas": [
            "triangle_angleSum",
            "triangle_angleSum",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem self_fullAngle : ∀ (A B C O : Point) (AB BC CA: Line), formTriangle A B C AB BC CA ∧ insideTriangle O A B C AB BC CA → ∠A:O:C + ∠ C:O:B + ∠ B:O:A = ∟ + ∟ +  ∟ + ∟ := by\n",
        "formal_proof": "theorem self_fullAngle : ∀ (A B C O : Point) (AB BC CA: Line), formTriangle A B C AB BC CA ∧ insideTriangle O A B C AB BC CA → ∠A:O:C + ∠ C:O:B + ∠ B:O:A = ∟ + ∟ +  ∟ + ∟ := by\n  euclid_intros\n  euclid_apply triangle_angleSum A O B\n  euclid_apply triangle_angleSum C O B\n  euclid_apply triangle_angleSum A O C\n  euclid_apply triangle_angleSum A B C\n  euclid_finish\n\n--Theorem 1.3 (Inscribed Angle Theorem). If ∠A C B is inscribed in a circle, then it subtends an arc with measure 2∠A C B.\n--Draw in O C. Set α = ∠A C O and β = ∠B C O, and let θ = α + β. Because A O = C O we have ∠O A C = ∠O C A = α, so ∠A O C = 180° − 2α. Similarly ∠B O C = 180° − 2β. Hence ∠A O B = 360° − [(180° − 2α) + (180° − 2β)] = 2θ.\n",
        "source": "LeanGeo/Theorem/E13.lean"
    },
    {
        "name": "inscribed_angle_theorem_1",
        "using_lemmas": [
            "self_fullAngle",
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "isoTriangle_eqAngle",
            "isoTriangle_eqAngle",
            "triangle_angleSum",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inscribed_angle_theorem_1:\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (insideTriangle O A B C AB BC CA) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n",
        "formal_proof": "theorem inscribed_angle_theorem_1:\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (insideTriangle O A B C AB BC CA) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n  euclid_intros\n  euclid_apply self_fullAngle A B C O AB BC CA\n  euclid_apply line_from_points O C as OC\n  euclid_apply line_from_points O B as OB\n  euclid_apply line_from_points O A as OA\n  euclid_apply isoTriangle_eqAngle O A C\n  euclid_apply isoTriangle_eqAngle O C B\n  euclid_apply triangle_angleSum A O C\n  euclid_apply triangle_angleSum C O B\n  euclid_finish\n\n",
        "source": "LeanGeo/Theorem/E13.lean"
    },
    {
        "name": "inscribed_angle_theorem",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem inscribed_angle_theorem:\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (O.sameSide C AB) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n",
        "formal_proof": "theorem inscribed_angle_theorem:\n  ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (O.sameSide C AB) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n    → ∠ A:O:B = ∠ A:C:B + ∠ A:C:B := by\n  sorry\n\n",
        "source": "LeanGeo/Theorem/E13.lean"
    },
    {
        "name": "circumcenter_inscribed_angle_complementary",
        "using_lemmas": [
            "inscribed_angle_theorem",
            "isoTriangle_eqAngle",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem circumcenter_inscribed_angle_complementary : ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (O.sameSide C AB) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n  → ∠ O:B:A +  ∠ A:C:B= ∟ := by\n",
        "formal_proof": "theorem circumcenter_inscribed_angle_complementary : ∀ (A B C O : Point) (AB BC CA: Line) (Ω : Circle), (formTriangle A B C AB BC CA) ∧ (O.sameSide C AB) ∧ (A.onCircle Ω) ∧ (B.onCircle Ω) ∧ (C.onCircle Ω) ∧ (O.isCentre Ω)\n  → ∠ O:B:A +  ∠ A:C:B= ∟ := by\n  euclid_intros\n  euclid_apply inscribed_angle_theorem A B C O AB BC CA Ω\n  euclid_apply isoTriangle_eqAngle O A B\n  euclid_apply triangle_angleSum O A B\n  euclid_finish\n",
        "source": "LeanGeo/Theorem/E13.lean"
    },
    {
        "name": "diameter_rightAngle'",
        "using_lemmas": [
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "line_from_points",
            "isoTriangle_eqAngle",
            "isoTriangle_eqAngle",
            "triangle_angleSum"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem diameter_rightAngle' : ∀ (a b c o: Point) (C: Circle), o.isCentre C ∧  (diameter a b o C) ∧ (c.onCircle C) ∧ (c ≠ a) ∧ (c ≠ b) → ∠ a:c:b = ∟ := by\n",
        "formal_proof": "theorem diameter_rightAngle' : ∀ (a b c o: Point) (C: Circle), o.isCentre C ∧  (diameter a b o C) ∧ (c.onCircle C) ∧ (c ≠ a) ∧ (c ≠ b) → ∠ a:c:b = ∟ := by\n  euclid_intros\n  euclid_apply line_from_points a b as AB\n  euclid_apply line_from_points b c as BC\n  euclid_apply line_from_points c a as CA\n  euclid_assert between a o b\n  euclid_apply line_from_points a b as ab\n  euclid_assert isoTriangle o a c\n  euclid_assert isoTriangle o b c\n  euclid_apply isoTriangle_eqAngle o a c\n  euclid_apply isoTriangle_eqAngle o b c\n  euclid_assert triangle a b c\n  euclid_apply triangle_angleSum a b c\n  euclid_assert ∠o:a:c = ∠b:a:c\n  euclid_assert ∠o:b:c = ∠a:b:c\n  euclid_assert ∠a:c:b = ∠ a:c:o + ∠o:c:b\n  euclid_finish\n",
        "source": "LeanGeo/Theorem/1-6.lean"
    },
    {
        "name": "cyclic_power",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem cyclic_power: ∀ (a b c d e: Point),distinctFourPoints a b c d ∧ cyclic a b c d ∧ (coll a b e) ∧ (coll c d e) → |(e─a)| * |(e─b)| = |(e─c)| * |(e─d)| := by\n",
        "formal_proof": "theorem cyclic_power: ∀ (a b c d e: Point),distinctFourPoints a b c d ∧ cyclic a b c d ∧ (coll a b e) ∧ (coll c d e) → |(e─a)| * |(e─b)| = |(e─c)| * |(e─d)| := by\n  sorry -/\n\n",
        "source": "LeanGeo/Everyday/imo_2008_1.lean"
    },
    {
        "name": "triangle_median_line_parallel'",
        "using_lemmas": [
            "(△",
            "eqAlternateExteriorAngle_parallel"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem triangle_median_line_parallel' : ∀ (a b c d e : Point) (AB BC CA DE: Line), formTriangle a b c AB BC CA ∧ distinctPointsOnLine d e DE ∧ midpoint a d b ∧ midpoint a e c →  ¬ BC.intersectsLine DE:= by\n",
        "formal_proof": "theorem triangle_median_line_parallel' : ∀ (a b c d e : Point) (AB BC CA DE: Line), formTriangle a b c AB BC CA ∧ distinctPointsOnLine d e DE ∧ midpoint a d b ∧ midpoint a e c →  ¬ BC.intersectsLine DE:= by\n  euclid_intros\n  euclid_assert |(a─b)| * |(a─e)| = |(a─c)| * |(a─d)|\n  euclid_assert triangle a d e\n  euclid_assert (△ a:b:c).similar_test ((△ a:d:e))\n  euclid_apply (△ a:b:c).similar_property ((△ a:d:e))\n  euclid_assert ∠a:b:c = ∠a:d:e\n  euclid_apply eqAlternateExteriorAngle_parallel e d c b a DE BC AB\n  euclid_finish\n\n\n",
        "source": "LeanGeo/Everyday/imo_2008_1.lean"
    },
    {
        "name": "sameSide_eqAngle_coll",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem sameSide_eqAngle_coll : ∀(A B C D: Point) (AB : Line), distinctPointsOnLine A B AB ∧ (∠A:B:C = ∠A:B:D) ∧ D.sameSide C AB → coll B C D := by\n",
        "formal_proof": "theorem sameSide_eqAngle_coll : ∀(A B C D: Point) (AB : Line), distinctPointsOnLine A B AB ∧ (∠A:B:C = ∠A:B:D) ∧ D.sameSide C AB → coll B C D := by\n  sorry\n",
        "source": "LeanGeo/Everyday/imo_2008_1.lean"
    },
    {
        "name": "perp_same_line_coll",
        "using_lemmas": [
            "intersection_lines",
            "exists_distincts_points_on_line",
            "unique_perpLine",
            "sameSide_eqAngle_coll"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem perp_same_line_coll : ∀ (A B C: Point) (l AB AC : Line), (perpLine l AB ∧ perpLine l AC) ∧ (distinctPointsOnLine A B AB) ∧ (distinctPointsOnLine A C AC) → coll A B C := by\n",
        "formal_proof": "theorem perp_same_line_coll : ∀ (A B C: Point) (l AB AC : Line), (perpLine l AB ∧ perpLine l AC) ∧ (distinctPointsOnLine A B AB) ∧ (distinctPointsOnLine A C AC) → coll A B C := by\n  euclid_intros\n  euclid_apply intersection_lines AB l as P\n  euclid_apply exists_distincts_points_on_line l P as Q\n  euclid_apply unique_perpLine A l as L\n  sorry\n  --euclid_assert AB = L\n  --euclid_assert AC = L\n  --euclid_assert AB = AC\n  --euclid_finish\n  --euclid_apply sameSide_eqAngle_coll P Q A B l\n\n",
        "source": "LeanGeo/Everyday/imo_2008_1.lean"
    },
    {
        "name": "imo_08",
        "using_lemmas": [
            "line_from_points",
            "intersecting_circles_perpendicular_bisector",
            "line_from_points",
            "line_from_points",
            "intersection_lines",
            "triangle_median_line_parallel",
            "(perpBisector_equiv",
            "perpLine_parallel_perpLine",
            "perp_same_line_coll",
            "cyclic_power",
            "cyclic_power",
            "power_cyclic"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem imo_08 : ∀ (A B C H E F C1 C2 B1 B2 H X: Point) (AB BC CA : Line) (ΓA ΓB :Circle), (ΓA.intersectsCircle ΓB ) ∧ formTriangle A B C AB BC CA ∧ midpoint A F B ∧ midpoint A E C ∧ C1.onCircle ΓA ∧ C2.onCircle ΓA ∧ B1.onCircle ΓB ∧ B2.onCircle ΓB ∧ orthoCentre H A B C ∧ between A C1 F ∧ between C1 F C2 ∧ between A B1 E ∧ between B1 E B2 ∧ H.onCircle ΓA ∧ H.onCircle ΓB  ∧ circlesIntersectsAtTwoPoints ΓA ΓB X H ∧ (X ≠ H) ∧ insideTriangle X A B C AB BC CA ∧ insideTriangle H A B C AB BC CA ∧ E.isCentre ΓB ∧ F.isCentre ΓA→ cyclic C1 C2 B2 B1 := by\n",
        "formal_proof": "theorem imo_08 : ∀ (A B C H E F C1 C2 B1 B2 H X: Point) (AB BC CA : Line) (ΓA ΓB :Circle), (ΓA.intersectsCircle ΓB ) ∧ formTriangle A B C AB BC CA ∧ midpoint A F B ∧ midpoint A E C ∧ C1.onCircle ΓA ∧ C2.onCircle ΓA ∧ B1.onCircle ΓB ∧ B2.onCircle ΓB ∧ orthoCentre H A B C ∧ between A C1 F ∧ between C1 F C2 ∧ between A B1 E ∧ between B1 E B2 ∧ H.onCircle ΓA ∧ H.onCircle ΓB  ∧ circlesIntersectsAtTwoPoints ΓA ΓB X H ∧ (X ≠ H) ∧ insideTriangle X A B C AB BC CA ∧ insideTriangle H A B C AB BC CA ∧ E.isCentre ΓB ∧ F.isCentre ΓA→ cyclic C1 C2 B2 B1 := by\n  euclid_intros\n  euclid_assert cyclic C1 C2 X H\n  euclid_assert cyclic B1 B2 H X\n  euclid_apply line_from_points E F as EF\n  have h: coll A X H := by\n    euclid_apply intersecting_circles_perpendicular_bisector ΓA ΓB F E X H EF\n    euclid_apply line_from_points X H as XH\n    euclid_apply line_from_points A H as AH\n    euclid_apply intersection_lines AH BC as P\n    euclid_assert perpLine AH BC\n    euclid_apply triangle_median_line_parallel A B C F E AB BC CA EF\n    euclid_apply (perpBisector_equiv X H EF).1 as (Q, L2)\n    euclid_assert perpLine XH EF\n    euclid_apply perpLine_parallel_perpLine BC AH EF\n    euclid_apply perp_same_line_coll H X A EF XH AH\n    euclid_finish\n  euclid_apply cyclic_power B1 B2 X H A\n  euclid_apply cyclic_power C1 C2 X H A\n  have h2 : |(A─B1)| * |(A─B2)| = |(A─C1)| * |(A─C2)| := by\n    euclid_finish\n  euclid_apply power_cyclic C1 C2 B1 B2 A\n  euclid_finish\n\nend LeanGeo\n",
        "source": "LeanGeo/Everyday/imo_2008_1.lean"
    },
    {
        "name": "eqChord_eqChord",
        "using_lemmas": [
            "cyclic_property",
            "line_from_points",
            "line_from_points",
            "intersection_lines",
            "Triangle.congruent_property"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem eqChord_eqChord : ∀ (A D B C : Point)(AD DB BC CA : Line) (P : Circle), cyclicQuadrilateral A D B C AD DB BC CA P ∧ |(A─D)| = |(C─B)|→ |(A─B)| = |(C─D)| := by\n",
        "formal_proof": "theorem eqChord_eqChord : ∀ (A D B C : Point)(AD DB BC CA : Line) (P : Circle), cyclicQuadrilateral A D B C AD DB BC CA P ∧ |(A─D)| = |(C─B)|→ |(A─B)| = |(C─D)| := by\n  euclid_intros\n  euclid_apply cyclic_property A D B C AD DB BC CA P\n  euclid_assert ∠D:A:B = ∠D:C:B\n  euclid_assert ∠A:D:C = ∠A:B:C\n  euclid_apply line_from_points A B as AB\n  euclid_apply line_from_points C D as CD\n  euclid_apply intersection_lines AB CD as E\n  euclid_assert ∠B:C:E = ∠D:A:E\n  euclid_assert ∠A:D:E = ∠C:B:E\n  euclid_assert Triangle.congruent_test (△A:D:E) (△C:B:E)\n  euclid_apply Triangle.congruent_property (△A:D:E) (△C:B:E)\n  euclid_finish\n",
        "source": "LeanGeo/Everyday/0411.lean"
    },
    {
        "name": "day137",
        "using_lemmas": [
            "diameter_rightAngle",
            "diameter_rightAngle",
            "eqChord_eqInsctribedAngle",
            "triangle_angleSum",
            "triangle_anglePositive",
            "triangle_angleSum",
            "triangle_anglePositive",
            "Triangle.congruent_property"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem day137: ∀ (A B C D O : Point) (P : Circle),\nmidpoint A O B ∧ O.isCentre P ∧ A.onCircle P ∧ B.onCircle P ∧ C.onCircle P ∧ C ≠ B ∧ C ≠ A ∧ D.onCircle P ∧ D ≠ A ∧ D ≠ B ∧ D ≠ C ∧ |(A─D)| =|(A─C)| →\n∠C:A:B=∠D:A:B := by\n",
        "formal_proof": "theorem day137: ∀ (A B C D O : Point) (P : Circle),\nmidpoint A O B ∧ O.isCentre P ∧ A.onCircle P ∧ B.onCircle P ∧ C.onCircle P ∧ C ≠ B ∧ C ≠ A ∧ D.onCircle P ∧ D ≠ A ∧ D ≠ B ∧ D ≠ C ∧ |(A─D)| =|(A─C)| →\n∠C:A:B=∠D:A:B := by\n  euclid_intros\n  euclid_apply diameter_rightAngle A B C O P\n  euclid_apply diameter_rightAngle A B D O P\n  euclid_apply eqChord_eqInsctribedAngle A B C A B D P\n  euclid_apply triangle_angleSum A B D\n  euclid_apply triangle_anglePositive A B D\n  euclid_assert ∠A:B:D < ∟\n  euclid_apply triangle_angleSum A B C\n  euclid_apply triangle_anglePositive A B C\n  euclid_assert ∠A:B:C < ∟\n  euclid_assert ∠A:B:D = ∠A:B:C\n  euclid_assert ∠A:D:B = ∠A:C:B\n  euclid_assert Triangle.congruent_test (△A:B:C) (△ A:B:D)\n  euclid_apply Triangle.congruent_property (△A:B:C) (△ A:B:D)\n  simp at *\n  euclid_finish\n\n",
        "source": "LeanGeo/Everyday/0409.lean"
    },
    {
        "name": "inscribed_trapezoid_isosceles",
        "using_lemmas": [
            "cyclic_property",
            "line_from_points",
            "parallel_eqAlternateAngles",
            "eqInscribedAngle_eqChord"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem inscribed_trapezoid_isosceles: ∀ (A B C D: Point) (P : Circle) (AB BC CD DA : Line),\n(cyclicQuadrilateral A B C D AB BC CD DA P) ∧ (¬ AB.intersectsLine CD)\n→ |(B─C)| = |(A─D)| := by\n",
        "formal_proof": "theorem inscribed_trapezoid_isosceles: ∀ (A B C D: Point) (P : Circle) (AB BC CD DA : Line),\n(cyclicQuadrilateral A B C D AB BC CD DA P) ∧ (¬ AB.intersectsLine CD)\n→ |(B─C)| = |(A─D)| := by\n  euclid_intros\n  euclid_apply cyclic_property A B C D AB BC CD DA P\n  euclid_apply line_from_points B D as BD\n  euclid_assert C.opposingSides A BD\n  euclid_apply parallel_eqAlternateAngles CD AB BD D B C A\n  simp at *\n  euclid_apply eqInscribedAngle_eqChord C D B A B D P\n  euclid_finish\n\n",
        "source": "LeanGeo/Everyday/0409.lean"
    },
    {
        "name": "day1382",
        "using_lemmas": [
            "(perpBisector_equiv",
            "perpLine_parallel_perpLine",
            "exists_centre"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem day1382: ∀ (A B C D: Point) (P : Circle) (L AB CD : Line),\n(cyclicQuadrilateral A B C D AB BC CD DA P) ∧ (¬ AB.intersectsLine CD) ∧\nperpBisector A B L → perpBisector C D L := by\n",
        "formal_proof": "theorem day1382: ∀ (A B C D: Point) (P : Circle) (L AB CD : Line),\n(cyclicQuadrilateral A B C D AB BC CD DA P) ∧ (¬ AB.intersectsLine CD) ∧\nperpBisector A B L → perpBisector C D L := by\n  euclid_intros\n  euclid_apply (perpBisector_equiv A B L).1 as (Q, L2)\n  euclid_assert perpLine AB L\n  euclid_apply perpLine_parallel_perpLine AB L CD\n  euclid_apply exists_centre P as O\n  sorry\n",
        "source": "LeanGeo/Everyday/0409.lean"
    },
    {
        "name": "day156",
        "using_lemmas": [
            "angle_between_transfer",
            "pythagorean_point",
            "intersecting_chord"
        ],
        "proof_state": "with_sorry",
        "formal_statement": "theorem day156 : ∀ (A B M N O P : Point) (AB NP OP : Line) (C: Circle),\ndiameter A B O C∧ P.onCircle C ∧ O.isCentre C∧ ∠A:O:P = ∟ ∧ between A M O ∧ between N M P ∧ N.onCircle C ∧\ndistinctPointsOnLine A B AB ∧ distinctPointsOnLine N P NP ∧ distinctPointsOnLine O P OP →    |(A─B)| * |(A─B)| = 2* |(P─M)| * |(N─P)| := by\n",
        "formal_proof": "theorem day156 : ∀ (A B M N O P : Point) (AB NP OP : Line) (C: Circle),\ndiameter A B O C∧ P.onCircle C ∧ O.isCentre C∧ ∠A:O:P = ∟ ∧ between A M O ∧ between N M P ∧ N.onCircle C ∧\ndistinctPointsOnLine A B AB ∧ distinctPointsOnLine N P NP ∧ distinctPointsOnLine O P OP →    |(A─B)| * |(A─B)| = 2* |(P─M)| * |(N─P)| := by\n  euclid_intros\n  euclid_assert P ≠ O\n  euclid_assert P ≠ M\n  by_cases (O = M)\n  · sorry\n  · euclid_assert triangle P O M\n    euclid_apply angle_between_transfer A M O P\n    euclid_assert ∠M:O:P = ∟\n    euclid_apply pythagorean_point O P M\n    euclid_apply intersecting_chord A B P N M C\n    euclid_assert |(P─N)| = |(P─M)| + |(M─N)|\n    euclid_assert |(A─M)| + |(O─M)|= |(A─O)|\n    euclid_assert |(M─B)| = |(O─M)| + |(B─O)|\n    euclid_assert |(A─O)| = |(P─O)|\n    euclid_assert |(B─O)| = |(P─O)|\n    have h1: |(P─M)| * (|(P─M)| + |(M─N)|) = |(P─M)| * |(P─N)| := by\n      simp_all\n    have h2: |(P─M)| * |(P─N)| = 2 * |(P─O)| * |(P─O)| := by\n      calc\n        |(P─M)| * |(P─N)| = |(P─M)| * (|(P─M)| + |(M─N)|) := by simp_all\n        _ = |(P─M)| * |(P─M)| + |(P─M)| * |(M─N)|:= by ring\n        _ = |(P─O)| * |(P─O)| + |(O─M)| * |(O─M)| + |(A─M)| * |(M─B)| := by simp_all\n        _ = |(P─O)| * |(P─O)| + |(O─M)| * |(O─M)| + (|(A─O)| - |(O─M)|) * |(M─B)| := by sorry\n        _ = |(P─O)| * |(P─O)| + |(O─M)| * |(O─M)| + (|(A─O)| - |(O─M)|) * (|(B─O)|+ |(O─M)|) := by sorry\n        _ = |(P─O)| * |(P─O)| + |(O─M)| * |(O─M)| + (|(P─O)| - |(O─M)|) * (|(P─O)|+ |(O─M)|) := by simp_all\n        _ = _ := by ring\n    euclid_assert |(A─B)| = 2 * |(P─O)|\n    euclid_finish\n",
        "source": "LeanGeo/Everyday/0420.lean"
    },
    {
        "name": "chord_inside",
        "using_lemmas": [],
        "proof_state": "whole_proof",
        "formal_statement": "theorem chord_inside : ∀ (O: Circle) (A B C: Point), A.onCircle O ∧ B.onCircle O ∧ between A C B → C.insideCircle O := by\n",
        "formal_proof": "theorem chord_inside : ∀ (O: Circle) (A B C: Point), A.onCircle O ∧ B.onCircle O ∧ between A C B → C.insideCircle O := by\n  euclid_intros\n  euclid_finish\n\n",
        "source": "LeanGeo/Everyday/0415.lean"
    },
    {
        "name": "two_perpAngle_eqPoint",
        "using_lemmas": [],
        "proof_state": "with_sorry",
        "formal_statement": "theorem two_perpAngle_eqPoint: ∀ (O A B: Point), (∠O:A:B = ∟) ∧ (∠O:B:A = ∟) → A = B := by\n",
        "formal_proof": "theorem two_perpAngle_eqPoint: ∀ (O A B: Point), (∠O:A:B = ∟) ∧ (∠O:B:A = ∟) → A = B := by\n  sorry\n\n",
        "source": "LeanGeo/Everyday/0415.lean"
    },
    {
        "name": "chord_bisector",
        "using_lemmas": [
            "intersection_lines",
            "eqSide_eqAngle",
            "two_perpAngle_eqPoint",
            "eqSide_eqAngle",
            "two_perpAngle_eqPoint",
            "isoTriangle_threeLine_concidence",
            "(perpBisector_equiv"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem chord_bisector : ∀ (O A B: Point) (C: Circle) (AB L: Line), O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ distinctPointsOnLine A B AB ∧ perpLine AB L\n  → O.onLine L →  perpBisector A B L := by\n",
        "formal_proof": "theorem chord_bisector : ∀ (O A B: Point) (C: Circle) (AB L: Line), O.isCentre C ∧ A.onCircle C ∧ B.onCircle C ∧ distinctPointsOnLine A B AB ∧ perpLine AB L\n  → O.onLine L →  perpBisector A B L := by\n  euclid_intros\n  euclid_apply intersection_lines AB L as F\n  have h1 : |(A─F)| = |(F─B)| := by\n    by_cases triangle A B O\n    . euclid_assert isoTriangle O A B\n      euclid_assert coll A B F\n      euclid_assert perpLineatPoint AB L F\n      simp at *\n      have h2 : A ≠ F := by\n        by_contra\n        euclid_assert ∠B:A:O = ∟\n        euclid_apply eqSide_eqAngle O A B\n        euclid_assert ∠A:B:O = ∟\n        euclid_apply two_perpAngle_eqPoint O A B\n        euclid_finish\n      have h3: B ≠ F := by\n        by_contra\n        euclid_assert ∠A:B:O = ∟\n        euclid_apply eqSide_eqAngle O A B\n        euclid_assert ∠B:A:O = ∟\n        euclid_apply two_perpAngle_eqPoint O A B\n        euclid_finish\n      euclid_assert ∠A:F:O = ∟\n      euclid_apply isoTriangle_threeLine_concidence O A B F\n      euclid_finish\n    · euclid_assert between A O B\n      euclid_assert O = F\n      euclid_finish\n\n  euclid_apply (perpBisector_equiv A B L).mpr\n  euclid_finish\n",
        "source": "LeanGeo/Everyday/0415.lean"
    },
    {
        "name": "Parallel_Thm17",
        "using_lemmas": [
            "Elements.Book1.proposition_29'''",
            "Elements.Book1.proposition_29'''"
        ],
        "proof_state": "whole_proof",
        "formal_statement": "theorem Parallel_Thm17 : ∀ (S V T U W : Point) (SV TU SU TV : Line),\ndistinctPointsOnLine S V SV ∧\ndistinctPointsOnLine T U TU ∧\ndistinctPointsOnLine S U SU ∧\ndistinctPointsOnLine T V TV ∧\ntwoLinesIntersectAtPoint SU TV W ∧ between S W U ∧ between T W V ∧\n∠ T:U:W = ∠ U:T:W ∧\n¬ SV.intersectsLine TU →\n∠ W:V:S = ∠ W:S:V := by\n",
        "formal_proof": "theorem Parallel_Thm17 : ∀ (S V T U W : Point) (SV TU SU TV : Line),\ndistinctPointsOnLine S V SV ∧\ndistinctPointsOnLine T U TU ∧\ndistinctPointsOnLine S U SU ∧\ndistinctPointsOnLine T V TV ∧\ntwoLinesIntersectAtPoint SU TV W ∧ between S W U ∧ between T W V ∧\n∠ T:U:W = ∠ U:T:W ∧\n¬ SV.intersectsLine TU →\n∠ W:V:S = ∠ W:S:V := by\n  euclid_intros\n  have : ∠ W:S:V = ∠ T:U:W := by\n    euclid_apply Elements.Book1.proposition_29''' T V U S TU SV SU\n    euclid_finish\n  have : ∠ U:T:W = ∠ W:V:S := by\n    euclid_apply Elements.Book1.proposition_29''' U S T V TU SV TV\n    euclid_finish\n  euclid_finish\n",
        "source": "LeanGeo/Everyday/test.lean"
    }
]