import Smt.Data.Graph
import Smt.Translate.Commands
import Smt.Translate
import Smt.Tactic.EqnDef
import Smt.Util
import Smt.Translate.Query

namespace Smt.Translate.Query

open Lean Expr Meta
open Term

/--
Adds a command for a new constant to the SMT command cache and updates the dependency graph.

* `oldAxiomExprs`: the expressions corresponding to the types of all currently cached axioms.
* `cName`: the name of the axiom to be added to the cache.
* `initialState`: the current state of the global dependency graph.

Returns a tuple of the form `(new global dependency graph, new list of cached axioms, list of SMT commands for all of the axioms)`.
-/
def addCommandForConstant
  (oldAxiomExprs : List Expr)
  (cName : Name)
  (initialState : QueryBuilderM.State)
  : MetaM (QueryBuilderM.State × List Expr × List Command) := do
  let constInfo ← getConstInfo cName
  let constExpr := mkConst cName (constInfo.levelParams.map Level.param)
  let ((_, st), r) ←
    QueryBuilderM.buildDependencyGraph (mkConst `True)
    |>.run { toDefine := oldAxiomExprs ++ [constExpr] : QueryBuilderM.Config }
    |>.run initialState
    |>.run { uniqueFVarNames := {} : TranslationM.State }
  let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldAxiomExprs ++ [constExpr]) (emitVertex st.commands)) []
  return ⟨st, oldAxiomExprs ++ [constExpr], cmds⟩

/--
Generates an SMT query by constructing a dependency graph from the given goal and hypotheses.

* `oldGoalExprs`: previously asserted expressions (e.g., from earlier goals or axioms).
* `goal`: the current Lean expression representing the goal to be proved.
* `hs`: additional hypotheses to be included in the query.
* `fvNames`: a mapping from free variable identifiers to human-readable names, used during translation.
* `initialState`: the current state of the dependency graph and translation context.

Returns a pair:
* the updated dependency graph state, and
* the list of SMT commands forming the full query (with the goal asserted last to simplify proof reconstruction).
-/
def generateQuery'
  (oldGoalExprs : List Expr)
  (goal : Expr)
  (hs : List Expr)
  (fvNames : Std.HashMap FVarId String)
  (initialState : QueryBuilderM.State)
  : MetaM (QueryBuilderM.State × List Command) :=
  withTraceNode `smt.translate.query (fun _ => pure .nil) do
    trace[smt.translate.query] "Goal: {← inferType goal}"
    trace[smt.translate.query] "Provided Hints: {hs}"
    let ((_, st), _) ← do
      QueryBuilderM.buildDependencyGraph goal
      |>.run { toDefine := oldGoalExprs ++ hs : QueryBuilderM.Config }
      |>.run initialState
      |>.run { uniqueFVarNames := fvNames : TranslationM.State }
    trace[smt.translate.query] "Dependency Graph: {st.graph}"
    -- The type of the proof generated by a solver depends on the order of assertions.
    -- We assert the Lean goal at the end of the query to simplify unification during proof reconstruction.
    let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ hs ++ [goal]) (emitVertex st.commands)) []
    return (st, cmds.reverse)
