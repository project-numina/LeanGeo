import Smt.Data.Graph
import Smt.Translate.Commands
import Smt.Translate
import Smt.Tactic.EqnDef
import Smt.Util
import Smt.Translate.Query

namespace Smt.Translate.Query

open Lean Expr Meta
open Term

#check generateQuery


def addCommandForConstant (oldGoalExprs : List Expr) (cName : Name) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Expr × List Command) := do
  let constInfo ← getConstInfo cName
  let constExpr := mkConst cName (constInfo.levelParams.map Level.param)
  let ((_, st), r) ← do
    QueryBuilderM.buildDependencyGraph (mkConst `True)
    |>.run { toDefine := oldGoalExprs ++ [constExpr] : QueryBuilderM.Config }
    |>.run initialState
    |>.run { uniqueFVarNames := {} : TranslationM.State }
  dbg_trace r.depConstants.toList
  dbg_trace r.localFVars.toList.length
  dbg_trace r.depFVars.toList.length
  dbg_trace r.scopedNames.toList
  let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ [constExpr]) (emitVertex st.commands)) []
  return ⟨st, oldGoalExprs ++ [constExpr], cmds⟩


-- def addCommandForExpr (oldGoalExprs : List Expr) (e : Expr) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Expr × List Command) :=
--   withTraceNode `smt.translate.query (fun _ => pure .nil) do
--     let goalId ← Lean.mkFreshMVarId
--     Lean.Meta.withLocalDeclD goalId.name e fun g => do
--       let ((_, st), _) ← do
--         QueryBuilderM.buildDependencyGraph g
--         |>.run { toDefine := [] : QueryBuilderM.Config }
--         |>.run initialState
--         |>.run { uniqueFVarNames := {} : TranslationM.State }
--       -- trace[smt.translate.query] "Dependency Graph: {st.graph}"
--       -- The type of the proof generated by a solver depends on the order of asserions. We assert the
--       -- Lean goal at the end of the query to simplify unification during proof reconstruction.
--       let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ [g]) (emitVertex st.commands)) []
--       return ⟨st, oldGoalExprs ++ [g], cmds⟩

def generateQuery' (oldGoalExprs : List Expr) (goal : Expr) (hs : List Expr) (fvNames : Std.HashMap FVarId String) (initialState : QueryBuilderM.State) : MetaM (QueryBuilderM.State × List Command) :=
  withTraceNode `smt.translate.query (fun _ => pure .nil) do
    trace[smt.translate.query] "Goal: {← inferType goal}"
    trace[smt.translate.query] "Provided Hints: {hs}"
    let ((_, st), _) ← do
      QueryBuilderM.buildDependencyGraph goal
      |>.run { toDefine := oldGoalExprs ++ hs : QueryBuilderM.Config }
      |>.run initialState
      |>.run { uniqueFVarNames := fvNames : TranslationM.State }
    trace[smt.translate.query] "Dependency Graph: {st.graph}"
    -- The type of the proof generated by a solver depends on the order of asserions. We assert the
    -- Lean goal at the end of the query to simplify unification during proof reconstruction.
    let (_, cmds) ← StateT.run (st.graph.orderedDfs (oldGoalExprs ++ hs ++ [goal]) (emitVertex st.commands)) []
    return (st, cmds.reverse)
